/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injector, Injectable, SkipSelf, Optional } from '@angular/core';
import { Observable, of, forkJoin, from, throwError } from 'rxjs';
import { shareReplay, takeUntil, map, catchError, filter, mergeMap, defaultIfEmpty } from 'rxjs/operators';
import { META_KEY, NgxsConfig } from '../symbols';
import { topologicalSort, buildGraph, findFullParentPath, nameToState, propGetter, isObject } from './internals';
import { getActionTypeFromInstance, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
/**
 * State factory class
 * @ignore
 */
var StateFactory = /** @class */ (function () {
    function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._states = [];
        this._connected = false;
    }
    Object.defineProperty(StateFactory.prototype, "states", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.states : this._states;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a new state to the global defs.
     */
    /**
     * Add a new state to the global defs.
     * @param {?} oneOrManyStateClasses
     * @return {?}
     */
    StateFactory.prototype.add = /**
     * Add a new state to the global defs.
     * @param {?} oneOrManyStateClasses
     * @return {?}
     */
    function (oneOrManyStateClasses) {
        var e_1, _a, _b;
        /** @type {?} */
        var stateClasses;
        if (!Array.isArray(oneOrManyStateClasses)) {
            stateClasses = [oneOrManyStateClasses];
        }
        else {
            stateClasses = oneOrManyStateClasses;
        }
        /** @type {?} */
        var stateGraph = buildGraph(stateClasses);
        /** @type {?} */
        var sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        var depths = findFullParentPath(stateGraph);
        /** @type {?} */
        var nameGraph = nameToState(stateClasses);
        /** @type {?} */
        var mappedStores = [];
        var _loop_1 = function (name_1) {
            /** @type {?} */
            var stateClass = nameGraph[name_1];
            if (!stateClass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            /** @type {?} */
            var depth = depths[name_1];
            var actions = stateClass[META_KEY].actions;
            var defaults = stateClass[META_KEY].defaults;
            stateClass[META_KEY].path = depth;
            stateClass[META_KEY].selectFromAppState = propGetter(depth.split('.'), this_1._config);
            // ensure our store hasn't already been added
            // but dont throw since it could be lazy
            // loaded from different paths
            /** @type {?} */
            var has = this_1.states.find(function (s) { return s.name === name_1; });
            if (!has) {
                // create new instance of defaults
                if (Array.isArray(defaults)) {
                    defaults = tslib_1.__spread(defaults);
                }
                else if (isObject(defaults)) {
                    defaults = tslib_1.__assign({}, defaults);
                }
                else if (defaults === undefined) {
                    defaults = {};
                }
                /** @type {?} */
                var instance = this_1._injector.get(stateClass);
                mappedStores.push({
                    actions: actions,
                    instance: instance,
                    defaults: defaults,
                    name: name_1,
                    depth: depth
                });
            }
        };
        var this_1 = this;
        try {
            for (var sortedStates_1 = tslib_1.__values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                var name_1 = sortedStates_1_1.value;
                _loop_1(name_1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return)) _a.call(sortedStates_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        (_b = this.states).push.apply(_b, tslib_1.__spread(mappedStores));
        return mappedStores;
    };
    /**
     * Add a set of states to the store and return the defaulsts
     */
    /**
     * Add a set of states to the store and return the defaulsts
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addAndReturnDefaults = /**
     * Add a set of states to the store and return the defaulsts
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        if (stateClasses) {
            /** @type {?} */
            var states = this.add(stateClasses);
            /** @type {?} */
            var defaults = states.reduce(function (result, meta) { return setValue(result, meta.depth, meta.defaults); }, {});
            return { defaults: defaults, states: states };
        }
    };
    /**
     * Bind the actions to the handlers
     */
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    StateFactory.prototype.connectActionHandlers = /**
     * Bind the actions to the handlers
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._connected)
            return;
        this._actions
            .pipe(filter(function (ctx) { return ctx.status === "DISPATCHED" /* Dispatched */; }), mergeMap(function (_a) {
            var action = _a.action;
            return _this.invokeActions(_this._actions, action).pipe(map(function () { return (/** @type {?} */ ({ action: action, status: "SUCCESSFUL" /* Successful */ })); }), defaultIfEmpty((/** @type {?} */ ({ action: action, status: "CANCELED" /* Canceled */ }))), catchError(function (error) { return of((/** @type {?} */ ({ action: action, status: "ERRORED" /* Errored */, error: error }))); }));
        }))
            .subscribe(function (ctx) { return _this._actionResults.next(ctx); });
        this._connected = true;
    };
    /**
     * Invoke the init function on the states.
     */
    /**
     * Invoke the init function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    StateFactory.prototype.invokeInit = /**
     * Invoke the init function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    function (stateMetadatas) {
        var e_2, _a;
        try {
            for (var stateMetadatas_1 = tslib_1.__values(stateMetadatas), stateMetadatas_1_1 = stateMetadatas_1.next(); !stateMetadatas_1_1.done; stateMetadatas_1_1 = stateMetadatas_1.next()) {
                var metadata = stateMetadatas_1_1.value;
                /** @type {?} */
                var instance = metadata.instance;
                if (instance.ngxsOnInit) {
                    /** @type {?} */
                    var stateContext = this.createStateContext(metadata);
                    instance.ngxsOnInit(stateContext);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (stateMetadatas_1_1 && !stateMetadatas_1_1.done && (_a = stateMetadatas_1.return)) _a.call(stateMetadatas_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * Invoke actions on the states.
     */
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    StateFactory.prototype.invokeActions = /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    function (actions$, action) {
        var e_3, _a, e_4, _b;
        /** @type {?} */
        var results = [];
        try {
            for (var _c = tslib_1.__values(this.states), _d = _c.next(); !_d.done; _d = _c.next()) {
                var metadata = _d.value;
                /** @type {?} */
                var type = getActionTypeFromInstance(action);
                /** @type {?} */
                var actionMetas = metadata.actions[type];
                if (actionMetas) {
                    try {
                        for (var actionMetas_1 = tslib_1.__values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                            var actionMeta = actionMetas_1_1.value;
                            /** @type {?} */
                            var stateContext = this.createStateContext(metadata);
                            try {
                                /** @type {?} */
                                var result = metadata.instance[actionMeta.fn](stateContext, action);
                                if (result instanceof Promise) {
                                    result = from(result);
                                }
                                if (result instanceof Observable) {
                                    result = result.pipe(actionMeta.options.cancelUncompleted
                                        ? takeUntil(actions$.pipe(ofActionDispatched(action)))
                                        : map(function (r) { return r; })); // map acts like a noop
                                }
                                else {
                                    result = of({}).pipe(shareReplay());
                                }
                                results.push(result);
                            }
                            catch (e) {
                                results.push(throwError(e));
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (actionMetas_1_1 && !actionMetas_1_1.done && (_b = actionMetas_1.return)) _b.call(actionMetas_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    };
    /**
     * Create the state context
     */
    /**
     * Create the state context
     * @private
     * @param {?} metadata
     * @return {?}
     */
    StateFactory.prototype.createStateContext = /**
     * Create the state context
     * @private
     * @param {?} metadata
     * @return {?}
     */
    function (metadata) {
        return this._stateContextFactory.createStateContext(metadata);
    };
    StateFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateFactory.ctorParameters = function () { return [
        { type: Injector },
        { type: NgxsConfig },
        { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: InternalActions },
        { type: InternalDispatchedActionResults },
        { type: StateContextFactory }
    ]; };
    return StateFactory;
}());
export { StateFactory };
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._connected;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUUzRyxPQUFPLEVBQUUsUUFBUSxFQUFpQixVQUFVLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDakUsT0FBTyxFQUNMLGVBQWUsRUFDZixVQUFVLEVBQ1Ysa0JBQWtCLEVBQ2xCLFdBQVcsRUFDWCxVQUFVLEVBQ1YsUUFBUSxFQUdULE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsZUFBZSxFQUErQixNQUFNLG1CQUFtQixDQUFDO0FBQ2pGLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDOzs7OztBQU14RTtJQVNFLHNCQUNVLFNBQW1CLEVBQ25CLE9BQW1CLEVBR25CLGNBQTRCLEVBQzVCLFFBQXlCLEVBQ3pCLGNBQStDLEVBQy9DLG9CQUF5QztRQVB6QyxjQUFTLEdBQVQsU0FBUyxDQUFVO1FBQ25CLFlB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QUExQixVQUEyQixRQUFxQjtRQUM5QyxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNoRSxDQUFDOztnQkFwTEYsVUFBVTs7OztnQkF6QkYsUUFBUTtnQkFJaUIsVUFBVTtnQkFtQ2hCLFlBQVksdUJBRm5DLFFBQVEsWUFDUixRQUFRO2dCQXJCSixlQUFlO2dCQUNmLCtCQUErQjtnQkFDL0IsbUJBQW1COztJQTJMNUIsbUJBQUM7Q0FBQSxBQXJMRCxJQXFMQztTQXBMWSxZQUFZOzs7Ozs7SUFLdkIsK0JBQW9DOzs7OztJQUNwQyxrQ0FBMkI7Ozs7O0lBR3pCLGlDQUEyQjs7Ozs7SUFDM0IsK0JBQTJCOzs7OztJQUMzQixzQ0FFb0M7Ozs7O0lBQ3BDLGdDQUFpQzs7Ozs7SUFDakMsc0NBQXVEOzs7OztJQUN2RCw0Q0FBaUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RvciwgSW5qZWN0YWJsZSwgU2tpcFNlbGYsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCBmb3JrSm9pbiwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBzaGFyZVJlcGxheSwgdGFrZVVudGlsLCBtYXAsIGNhdGNoRXJyb3IsIGZpbHRlciwgbWVyZ2VNYXAsIGRlZmF1bHRJZkVtcHR5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgTUVUQV9LRVksIE5neHNMaWZlQ3ljbGUsIE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHtcclxuICB0b3BvbG9naWNhbFNvcnQsXHJcbiAgYnVpbGRHcmFwaCxcclxuICBmaW5kRnVsbFBhcmVudFBhdGgsXHJcbiAgbmFtZVRvU3RhdGUsXHJcbiAgcHJvcEdldHRlcixcclxuICBpc09iamVjdCxcclxuICBTdGF0ZUNsYXNzLFxyXG4gIE1hcHBlZFN0b3JlXHJcbn0gZnJvbSAnLi9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlLCBzZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgb2ZBY3Rpb25EaXNwYXRjaGVkIH0gZnJvbSAnLi4vb3BlcmF0b3JzL29mLWFjdGlvbic7XHJcbmltcG9ydCB7IEludGVybmFsQWN0aW9ucywgQWN0aW9uU3RhdHVzLCBBY3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnknO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRlIGZhY3RvcnkgY2xhc3NcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RhdGVGYWN0b3J5IHtcclxuICBnZXQgc3RhdGVzKCk6IE1hcHBlZFN0b3JlW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlcyA6IHRoaXMuX3N0YXRlcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3N0YXRlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xyXG4gIHByaXZhdGUgX2Nvbm5lY3RlZCA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX2luamVjdG9yOiBJbmplY3RvcixcclxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBAU2tpcFNlbGYoKVxyXG4gICAgcHJpdmF0ZSBfcGFyZW50RmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uUmVzdWx0czogSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgIHByaXZhdGUgX3N0YXRlQ29udGV4dEZhY3Rvcnk6IFN0YXRlQ29udGV4dEZhY3RvcnlcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIG5ldyBzdGF0ZSB0byB0aGUgZ2xvYmFsIGRlZnMuXHJcbiAgICovXHJcbiAgYWRkKG9uZU9yTWFueVN0YXRlQ2xhc3NlczogU3RhdGVDbGFzcyB8IFN0YXRlQ2xhc3NbXSk6IE1hcHBlZFN0b3JlW10ge1xyXG4gICAgbGV0IHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc1tdO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9uZU9yTWFueVN0YXRlQ2xhc3NlcykpIHtcclxuICAgICAgc3RhdGVDbGFzc2VzID0gW29uZU9yTWFueVN0YXRlQ2xhc3Nlc107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGF0ZUNsYXNzZXMgPSBvbmVPck1hbnlTdGF0ZUNsYXNzZXM7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RhdGVHcmFwaCA9IGJ1aWxkR3JhcGgoc3RhdGVDbGFzc2VzKTtcclxuICAgIGNvbnN0IHNvcnRlZFN0YXRlcyA9IHRvcG9sb2dpY2FsU29ydChzdGF0ZUdyYXBoKTtcclxuICAgIGNvbnN0IGRlcHRocyA9IGZpbmRGdWxsUGFyZW50UGF0aChzdGF0ZUdyYXBoKTtcclxuICAgIGNvbnN0IG5hbWVHcmFwaCA9IG5hbWVUb1N0YXRlKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICBjb25zdCBtYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkU3RhdGVzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlQ2xhc3MgPSBuYW1lR3JhcGhbbmFtZV07XHJcblxyXG4gICAgICBpZiAoIXN0YXRlQ2xhc3NbTUVUQV9LRVldKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZXMgbXVzdCBiZSBkZWNvcmF0ZWQgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3InKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGVwdGggPSBkZXB0aHNbbmFtZV07XHJcbiAgICAgIGNvbnN0IHsgYWN0aW9ucyB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcbiAgICAgIGxldCB7IGRlZmF1bHRzIH0gPSBzdGF0ZUNsYXNzW01FVEFfS0VZXTtcclxuXHJcbiAgICAgIHN0YXRlQ2xhc3NbTUVUQV9LRVldLnBhdGggPSBkZXB0aDtcclxuICAgICAgc3RhdGVDbGFzc1tNRVRBX0tFWV0uc2VsZWN0RnJvbUFwcFN0YXRlID0gcHJvcEdldHRlcihkZXB0aC5zcGxpdCgnLicpLCB0aGlzLl9jb25maWcpO1xyXG5cclxuICAgICAgLy8gZW5zdXJlIG91ciBzdG9yZSBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFkZGVkXHJcbiAgICAgIC8vIGJ1dCBkb250IHRocm93IHNpbmNlIGl0IGNvdWxkIGJlIGxhenlcclxuICAgICAgLy8gbG9hZGVkIGZyb20gZGlmZmVyZW50IHBhdGhzXHJcbiAgICAgIGNvbnN0IGhhcyA9IHRoaXMuc3RhdGVzLmZpbmQocyA9PiBzLm5hbWUgPT09IG5hbWUpO1xyXG4gICAgICBpZiAoIWhhcykge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgaW5zdGFuY2Ugb2YgZGVmYXVsdHNcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0cykpIHtcclxuICAgICAgICAgIGRlZmF1bHRzID0gWy4uLmRlZmF1bHRzXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRlZmF1bHRzKSkge1xyXG4gICAgICAgICAgZGVmYXVsdHMgPSB7IC4uLmRlZmF1bHRzIH07XHJcbiAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBkZWZhdWx0cyA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLl9pbmplY3Rvci5nZXQoc3RhdGVDbGFzcyk7XHJcblxyXG4gICAgICAgIG1hcHBlZFN0b3Jlcy5wdXNoKHtcclxuICAgICAgICAgIGFjdGlvbnMsXHJcbiAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgIGRlZmF1bHRzLFxyXG4gICAgICAgICAgbmFtZSxcclxuICAgICAgICAgIGRlcHRoXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YXRlcy5wdXNoKC4uLm1hcHBlZFN0b3Jlcyk7XHJcblxyXG4gICAgcmV0dXJuIG1hcHBlZFN0b3JlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIHNldCBvZiBzdGF0ZXMgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gdGhlIGRlZmF1bHN0c1xyXG4gICAqL1xyXG4gIGFkZEFuZFJldHVybkRlZmF1bHRzKHN0YXRlQ2xhc3NlczogYW55W10pOiB7IGRlZmF1bHRzOiBhbnk7IHN0YXRlczogTWFwcGVkU3RvcmVbXSB9IHtcclxuICAgIGlmIChzdGF0ZUNsYXNzZXMpIHtcclxuICAgICAgY29uc3Qgc3RhdGVzID0gdGhpcy5hZGQoc3RhdGVDbGFzc2VzKTtcclxuICAgICAgY29uc3QgZGVmYXVsdHMgPSBzdGF0ZXMucmVkdWNlKFxyXG4gICAgICAgIChyZXN1bHQ6IGFueSwgbWV0YTogTWFwcGVkU3RvcmUpID0+IHNldFZhbHVlKHJlc3VsdCwgbWV0YS5kZXB0aCwgbWV0YS5kZWZhdWx0cyksXHJcbiAgICAgICAge31cclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHsgZGVmYXVsdHMsIHN0YXRlcyB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCB0aGUgYWN0aW9ucyB0byB0aGUgaGFuZGxlcnNcclxuICAgKi9cclxuICBjb25uZWN0QWN0aW9uSGFuZGxlcnMoKSB7XHJcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkKSByZXR1cm47XHJcbiAgICB0aGlzLl9hY3Rpb25zXHJcbiAgICAgIC5waXBlKFxyXG4gICAgICAgIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguc3RhdHVzID09PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXHJcbiAgICAgICAgbWVyZ2VNYXAoKHsgYWN0aW9uIH0pID0+XHJcbiAgICAgICAgICB0aGlzLmludm9rZUFjdGlvbnModGhpcy5fYWN0aW9ucywgYWN0aW9uKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKCkgPT4gPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWwgfSksXHJcbiAgICAgICAgICAgIGRlZmF1bHRJZkVtcHR5KDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5DYW5jZWxlZCB9KSxcclxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PiBvZig8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRXJyb3JlZCwgZXJyb3IgfSkpXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKVxyXG4gICAgICApXHJcbiAgICAgIC5zdWJzY3JpYmUoY3R4ID0+IHRoaXMuX2FjdGlvblJlc3VsdHMubmV4dChjdHgpKTtcclxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2UgdGhlIGluaXQgZnVuY3Rpb24gb24gdGhlIHN0YXRlcy5cclxuICAgKi9cclxuICBpbnZva2VJbml0KHN0YXRlTWV0YWRhdGFzOiBNYXBwZWRTdG9yZVtdKSB7XHJcbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHN0YXRlTWV0YWRhdGFzKSB7XHJcbiAgICAgIGNvbnN0IGluc3RhbmNlOiBOZ3hzTGlmZUN5Y2xlID0gbWV0YWRhdGEuaW5zdGFuY2U7XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2Uubmd4c09uSW5pdCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlQ29udGV4dCA9IHRoaXMuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcclxuICAgICAgICBpbnN0YW5jZS5uZ3hzT25Jbml0KHN0YXRlQ29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZSBhY3Rpb25zIG9uIHRoZSBzdGF0ZXMuXHJcbiAgICovXHJcbiAgaW52b2tlQWN0aW9ucyhhY3Rpb25zJDogSW50ZXJuYWxBY3Rpb25zLCBhY3Rpb24pIHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHRoaXMuc3RhdGVzKSB7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbik7XHJcbiAgICAgIGNvbnN0IGFjdGlvbk1ldGFzID0gbWV0YWRhdGEuYWN0aW9uc1t0eXBlXTtcclxuXHJcbiAgICAgIGlmIChhY3Rpb25NZXRhcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgYWN0aW9uTWV0YSBvZiBhY3Rpb25NZXRhcykge1xyXG4gICAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhLmluc3RhbmNlW2FjdGlvbk1ldGEuZm5dKHN0YXRlQ29udGV4dCwgYWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnJvbShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uTWV0YS5vcHRpb25zLmNhbmNlbFVuY29tcGxldGVkXHJcbiAgICAgICAgICAgICAgICAgID8gdGFrZVVudGlsKGFjdGlvbnMkLnBpcGUob2ZBY3Rpb25EaXNwYXRjaGVkKGFjdGlvbikpKVxyXG4gICAgICAgICAgICAgICAgICA6IG1hcChyID0+IHIpXHJcbiAgICAgICAgICAgICAgKTsgLy8gbWFwIGFjdHMgbGlrZSBhIG5vb3BcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBvZih7fSkucGlwZShzaGFyZVJlcGxheSgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aHJvd0Vycm9yKGUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaChvZih7fSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmb3JrSm9pbihyZXN1bHRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgc3RhdGUgY29udGV4dFxyXG4gICAqL1xyXG4gIHByaXZhdGUgY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhOiBNYXBwZWRTdG9yZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQ29udGV4dEZhY3RvcnkuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcclxuICB9XHJcbn1cclxuIl19