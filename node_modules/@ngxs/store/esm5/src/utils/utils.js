/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/**
 * Returns the type from an action instance.
 * @ignore
 * @param {?} action
 * @return {?}
 */
export function getActionTypeFromInstance(action) {
    if (action.constructor && action.constructor.type) {
        return action.constructor.type;
    }
    return action.type;
}
/**
 * Matches a action
 * @ignore
 * @param {?} action1
 * @return {?}
 */
export function actionMatcher(action1) {
    /** @type {?} */
    var type1 = getActionTypeFromInstance(action1);
    return function (action2) {
        return type1 === getActionTypeFromInstance(action2);
    };
}
/**
 * Set a deeply nested value. Example:
 *
 *   setValue({ foo: { bar: { eat: false } } },
 *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
 *
 * While it traverses it also creates new objects from top down.
 *
 * @ignore
 * @type {?}
 */
export var setValue = function (obj, prop, val) {
    obj = tslib_1.__assign({}, obj);
    /** @type {?} */
    var split = prop.split('.');
    /** @type {?} */
    var lastIndex = split.length - 1;
    split.reduce(function (acc, part, index) {
        if (index === lastIndex) {
            acc[part] = val;
        }
        else {
            acc[part] = Array.isArray(acc[part]) ? tslib_1.__spread(acc[part]) : tslib_1.__assign({}, acc[part]);
        }
        return acc && acc[part];
    }, obj);
    return obj;
};
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @type {?}
 */
export var getValue = function (obj, prop) {
    return prop.split('.').reduce(function (acc, part) { return acc && acc[part]; }, obj);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS8iLCJzb3VyY2VzIjpbInNyYy91dGlscy91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUlBLE1BQU0sVUFBVSx5QkFBeUIsQ0FBQyxNQUFXO0lBQ25ELElBQUksTUFBTSxDQUFDLFdBQVcsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRTtRQUNqRCxPQUFPLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO0tBQ2hDO0lBRUQsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ3JCLENBQUM7Ozs7Ozs7QUFNRCxNQUFNLFVBQVUsYUFBYSxDQUFDLE9BQVk7O1FBQ2xDLEtBQUssR0FBRyx5QkFBeUIsQ0FBQyxPQUFPLENBQUM7SUFFaEQsT0FBTyxVQUFTLE9BQVk7UUFDMUIsT0FBTyxLQUFLLEtBQUsseUJBQXlCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdEQsQ0FBQyxDQUFDO0FBQ0osQ0FBQzs7Ozs7Ozs7Ozs7O0FBWUQsTUFBTSxLQUFPLFFBQVEsR0FBRyxVQUFDLEdBQVEsRUFBRSxJQUFZLEVBQUUsR0FBUTtJQUN2RCxHQUFHLHdCQUFRLEdBQUcsQ0FBRSxDQUFDOztRQUVYLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQzs7UUFDdkIsU0FBUyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQztJQUVsQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLO1FBQzVCLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUN2QixHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO1NBQ2pCO2FBQU07WUFDTCxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLGtCQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLHNCQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBRSxDQUFDO1NBQzFFO1FBRUQsT0FBTyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUVSLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQzs7Ozs7Ozs7O0FBU0QsTUFBTSxLQUFPLFFBQVEsR0FBRyxVQUFDLEdBQVEsRUFBRSxJQUFZO0lBQzdDLE9BQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBQyxHQUFRLEVBQUUsSUFBWSxJQUFLLE9BQUEsR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBaEIsQ0FBZ0IsRUFBRSxHQUFHLENBQUM7QUFBekUsQ0FBeUUiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUmV0dXJucyB0aGUgdHlwZSBmcm9tIGFuIGFjdGlvbiBpbnN0YW5jZS5cclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uOiBhbnkpOiBzdHJpbmcge1xyXG4gIGlmIChhY3Rpb24uY29uc3RydWN0b3IgJiYgYWN0aW9uLmNvbnN0cnVjdG9yLnR5cGUpIHtcclxuICAgIHJldHVybiBhY3Rpb24uY29uc3RydWN0b3IudHlwZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhY3Rpb24udHlwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1hdGNoZXMgYSBhY3Rpb25cclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFjdGlvbk1hdGNoZXIoYWN0aW9uMTogYW55KSB7XHJcbiAgY29uc3QgdHlwZTEgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbjEpO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oYWN0aW9uMjogYW55KSB7XHJcbiAgICByZXR1cm4gdHlwZTEgPT09IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uMik7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgc2V0VmFsdWUoeyBmb286IHsgYmFyOiB7IGVhdDogZmFsc2UgfSB9IH0sXHJcbiAqICAgICAgJ2Zvby5iYXIuZWF0JywgdHJ1ZSkgLy89PiB7IGZvbzogeyBiYXI6IHsgZWF0OiB0cnVlIH0gfSB9XHJcbiAqXHJcbiAqIFdoaWxlIGl0IHRyYXZlcnNlcyBpdCBhbHNvIGNyZWF0ZXMgbmV3IG9iamVjdHMgZnJvbSB0b3AgZG93bi5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNldFZhbHVlID0gKG9iajogYW55LCBwcm9wOiBzdHJpbmcsIHZhbDogYW55KSA9PiB7XHJcbiAgb2JqID0geyAuLi5vYmogfTtcclxuXHJcbiAgY29uc3Qgc3BsaXQgPSBwcm9wLnNwbGl0KCcuJyk7XHJcbiAgY29uc3QgbGFzdEluZGV4ID0gc3BsaXQubGVuZ3RoIC0gMTtcclxuXHJcbiAgc3BsaXQucmVkdWNlKChhY2MsIHBhcnQsIGluZGV4KSA9PiB7XHJcbiAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xyXG4gICAgICBhY2NbcGFydF0gPSB2YWw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhY2NbcGFydF0gPSBBcnJheS5pc0FycmF5KGFjY1twYXJ0XSkgPyBbLi4uYWNjW3BhcnRdXSA6IHsgLi4uYWNjW3BhcnRdIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFjYyAmJiBhY2NbcGFydF07XHJcbiAgfSwgb2JqKTtcclxuXHJcbiAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFZhbHVlID0gKG9iajogYW55LCBwcm9wOiBzdHJpbmcpID0+XHJcbiAgcHJvcC5zcGxpdCgnLicpLnJlZHVjZSgoYWNjOiBhbnksIHBhcnQ6IHN0cmluZykgPT4gYWNjICYmIGFjY1twYXJ0XSwgb2JqKTtcclxuIl19