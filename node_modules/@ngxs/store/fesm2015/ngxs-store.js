import { InjectionToken, Injectable, NgZone, Optional, SkipSelf, Inject, ErrorHandler, isDevMode, Injector, NgModule } from '@angular/core';
import { map, filter, shareReplay, exhaustMap, take, takeUntil, catchError, mergeMap, defaultIfEmpty, distinctUntilChanged } from 'rxjs/operators';
import { Observable, Subject, BehaviorSubject, of, forkJoin, empty, throwError, from } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
/** @type {?} */
const FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
/** @type {?} */
const META_KEY = 'NGXS_META';
/** @type {?} */
const SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
/** @type {?} */
const NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');
/**
 * The NGXS config settings.
 */
class NgxsConfig {
    constructor() {
        this.compatibility = {
            strictContentSecurityPolicy: false
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            selectFromAppState: null,
            children: [],
            instance: null
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function getStoreMetadata(target) {
    return target[META_KEY];
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            selectFromAppState: null,
            originalFn: null,
            containerClass: null,
            selectorName: null
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    const copyOfPaths = [...paths];
    return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    const segments = paths;
    /** @type {?} */
    let seg = 'store.' + segments[0];
    /** @type {?} */
    let i = 0;
    /** @type {?} */
    const l = segments.length;
    /** @type {?} */
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    const fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
function buildGraph(stateClasses) {
    /** @type {?} */
    const findName = (stateClass) => {
        /** @type {?} */
        const meta = stateClasses.find(g => g === stateClass);
        if (!meta) {
            throw new Error(`Child state not found: ${stateClass}`);
        }
        if (!meta[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        return meta[META_KEY].name;
    };
    return stateClasses.reduce((result, stateClass) => {
        if (!stateClass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        const { name, children } = stateClass[META_KEY];
        result[name] = (children || []).map(findName);
        return result;
    }, {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
function nameToState(states) {
    return states.reduce((result, stateClass) => {
        if (!stateClass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        /** @type {?} */
        const meta = stateClass[META_KEY];
        result[meta.name] = stateClass;
        return result;
    }, {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
function findFullParentPath(obj, newObj = {}) {
    /** @type {?} */
    const visit = (child, keyToFind) => {
        for (const key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                const parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    };
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            const parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
function topologicalSort(graph) {
    /** @type {?} */
    const sorted = [];
    /** @type {?} */
    const visited = {};
    /** @type {?} */
    const visit = (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((dep) => {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        });
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    };
    Object.keys(graph).forEach(k => visit(k));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns the type from an action instance.
 * @ignore
 * @param {?} action
 * @return {?}
 */
function getActionTypeFromInstance(action) {
    if (action.constructor && action.constructor.type) {
        return action.constructor.type;
    }
    return action.type;
}
/**
 * Matches a action
 * @ignore
 * @param {?} action1
 * @return {?}
 */
function actionMatcher(action1) {
    /** @type {?} */
    const type1 = getActionTypeFromInstance(action1);
    return function (action2) {
        return type1 === getActionTypeFromInstance(action2);
    };
}
/**
 * Set a deeply nested value. Example:
 *
 *   setValue({ foo: { bar: { eat: false } } },
 *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
 *
 * While it traverses it also creates new objects from top down.
 *
 * @ignore
 * @type {?}
 */
const setValue = (obj, prop, val) => {
    obj = Object.assign({}, obj);
    /** @type {?} */
    const split = prop.split('.');
    /** @type {?} */
    const lastIndex = split.length - 1;
    split.reduce((acc, part, index) => {
        if (index === lastIndex) {
            acc[part] = val;
        }
        else {
            acc[part] = Array.isArray(acc[part]) ? [...acc[part]] : Object.assign({}, acc[part]);
        }
        return acc && acc[part];
    }, obj);
    return obj;
};
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @type {?}
 */
const getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will grab actions that have just been dispatched as well as actions that have completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofAction(...allowedTypes) {
    return ofActionOperator(allowedTypes);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been dispatched
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionDispatched(...allowedTypes) {
    return ofActionOperator(allowedTypes, "DISPATCHED" /* Dispatched */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been successfully completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionSuccessful(...allowedTypes) {
    return ofActionOperator(allowedTypes, "SUCCESSFUL" /* Successful */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been canceled
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionCanceled(...allowedTypes) {
    return ofActionOperator(allowedTypes, "CANCELED" /* Canceled */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just thrown an error
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionErrored(...allowedTypes) {
    return ofActionOperator(allowedTypes, "ERRORED" /* Errored */);
}
/**
 * @param {?} allowedTypes
 * @param {?=} status
 * @return {?}
 */
function ofActionOperator(allowedTypes, status) {
    /** @type {?} */
    const allowedMap = createAllowedMap(allowedTypes);
    return function (o) {
        return o.pipe(filterStatus(allowedMap, status), mapAction());
    };
}
/**
 * @param {?} allowedTypes
 * @param {?=} status
 * @return {?}
 */
function filterStatus(allowedTypes, status) {
    return filter((ctx) => {
        /** @type {?} */
        const actionType = getActionTypeFromInstance(ctx.action);
        /** @type {?} */
        const type = allowedTypes[actionType];
        return status ? type && ctx.status === status : type;
    });
}
/**
 * @return {?}
 */
function mapAction() {
    return map((ctx) => ctx.action);
}
/**
 * @param {?} types
 * @return {?}
 */
function createAllowedMap(types) {
    return types.reduce((acc, klass) => {
        acc[getActionTypeFromInstance(klass)] = true;
        return acc;
    }, {});
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Operator to run the `subscribe` in a Angular zone.
 * @template T
 * @param {?} zone
 * @return {?}
 */
function enterZone(zone) {
    return (source) => {
        return new Observable((sink) => {
            return source.subscribe({
                /**
                 * @param {?} x
                 * @return {?}
                 */
                next(x) {
                    zone.run(() => sink.next(x));
                },
                /**
                 * @param {?} e
                 * @return {?}
                 */
                error(e) {
                    zone.run(() => sink.error(e));
                },
                /**
                 * @return {?}
                 */
                complete() {
                    zone.run(() => sink.complete());
                }
            });
        });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
class OrderedSubject extends Subject {
    constructor() {
        super(...arguments);
        this._itemQueue = [];
        this._busyPushingNext = false;
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    next(value) {
        if (this._busyPushingNext) {
            this._itemQueue.unshift(value);
            return;
        }
        this._busyPushingNext = true;
        super.next(value);
        while (this._itemQueue.length > 0) {
            /** @type {?} */
            const nextValue = this._itemQueue.pop();
            super.next(nextValue);
        }
        this._busyPushingNext = false;
    }
}
/**
 * Internal Action stream that is emitted anytime an action is dispatched.
 */
class InternalActions extends OrderedSubject {
}
InternalActions.decorators = [
    { type: Injectable }
];
/**
 * Action stream that is emitted anytime an action is dispatched.
 *
 * You can listen to this in services to react without stores.
 */
class Actions extends Observable {
    /**
     * @param {?} actions$
     * @param {?} ngZone
     */
    constructor(actions$, ngZone) {
        super(observer => {
            actions$
                .pipe(enterZone(ngZone))
                .subscribe(res => observer.next(res), err => observer.error(err), () => observer.complete());
        });
    }
}
Actions.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Actions.ctorParameters = () => [
    { type: InternalActions },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Composes a array of functions from left to right. Example:
 *
 *      compose([fn, final])(state, action);
 *
 * then the funcs have a signature like:
 *
 *      function fn (state, action, next) {
 *          console.log('here', state, action, next);
 *          return next(state, action);
 *      }
 *
 *      function final (state, action) {
 *          console.log('here', state, action);
 *          return state;
 *      }
 *
 * the last function should not call `next`.
 *
 * @ignore
 * @type {?}
 */
const compose = funcs => (...args) => {
    /** @type {?} */
    const curr = funcs.shift();
    return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * BehaviorSubject of the entire state.
 * @ignore
 */
class StateStream extends BehaviorSubject {
    constructor() {
        super({});
    }
}
StateStream.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateStream.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Plugin manager class
 * @ignore
 */
class PluginManager {
    /**
     * @param {?} _parentManager
     * @param {?} _plugins
     */
    constructor(_parentManager, _plugins) {
        this._parentManager = _parentManager;
        this._plugins = _plugins;
        this.plugins = [];
        this.register();
    }
    /**
     * @private
     * @return {?}
     */
    register() {
        if (!this._plugins) {
            return;
        }
        this.plugins = this._plugins.map(plugin => {
            if (plugin.handle) {
                return plugin.handle.bind(plugin);
            }
            else {
                return plugin;
            }
        });
        if (this._parentManager) {
            this._parentManager.plugins.push(...this.plugins);
        }
    }
}
PluginManager.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PluginManager.ctorParameters = () => [
    { type: PluginManager, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: Array, decorators: [{ type: Inject, args: [NGXS_PLUGINS,] }, { type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal Action result stream that is emitted when an action is completed.
 * This is used as a method of returning the action result to the dispatcher
 * for the observable returned by the dispatch(...) call.
 * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.
 */
class InternalDispatchedActionResults extends Subject {
}
InternalDispatchedActionResults.decorators = [
    { type: Injectable }
];
class InternalDispatcher {
    /**
     * @param {?} _errorHandler
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _pluginManager
     * @param {?} _stateStream
     * @param {?} _ngZone
     */
    constructor(_errorHandler, _actions, _actionResults, _pluginManager, _stateStream, _ngZone) {
        this._errorHandler = _errorHandler;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._pluginManager = _pluginManager;
        this._stateStream = _stateStream;
        this._ngZone = _ngZone;
    }
    /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    dispatch(event) {
        /** @type {?} */
        const result = this._ngZone.runOutsideAngular(() => {
            if (Array.isArray(event)) {
                return forkJoin(event.map(a => this.dispatchSingle(a)));
            }
            else {
                return this.dispatchSingle(event);
            }
        });
        result.subscribe({
            error: error => this._ngZone.run(() => this._errorHandler.handleError(error))
        });
        return result.pipe(enterZone(this._ngZone));
    }
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    dispatchSingle(action) {
        /** @type {?} */
        const prevState = this._stateStream.getValue();
        /** @type {?} */
        const plugins = this._pluginManager.plugins;
        return ((/** @type {?} */ (compose([
            ...plugins,
            (nextState, nextAction) => {
                if (nextState !== prevState) {
                    this._stateStream.next(nextState);
                }
                /** @type {?} */
                const actionResult$ = this.getActionResultStream(nextAction);
                actionResult$.subscribe(ctx => this._actions.next(ctx));
                this._actions.next({ action: nextAction, status: "DISPATCHED" /* Dispatched */ });
                return this.createDispatchObservable(actionResult$);
            }
        ])(prevState, action)))).pipe(shareReplay());
    }
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    getActionResultStream(action) {
        return this._actionResults.pipe(filter((ctx) => ctx.action === action && ctx.status !== "DISPATCHED" /* Dispatched */), take(1), shareReplay());
    }
    /**
     * @private
     * @param {?} actionResult$
     * @return {?}
     */
    createDispatchObservable(actionResult$) {
        return actionResult$
            .pipe(exhaustMap((ctx) => {
            switch (ctx.status) {
                case "SUCCESSFUL" /* Successful */:
                    return of(this._stateStream.getValue());
                case "ERRORED" /* Errored */:
                    return throwError(ctx.error);
                default:
                    return empty();
            }
        }))
            .pipe(shareReplay());
    }
}
InternalDispatcher.decorators = [
    { type: Injectable }
];
/** @nocollapse */
InternalDispatcher.ctorParameters = () => [
    { type: ErrorHandler },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: PluginManager },
    { type: StateStream },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Object freeze code
 * https://github.com/jsdf/deep-freeze
 * @type {?}
 */
const deepFreeze = o => {
    Object.freeze(o);
    /** @type {?} */
    const oIsFunction = typeof o === 'function';
    /** @type {?} */
    const hasOwnProp = Object.prototype.hasOwnProperty;
    Object.getOwnPropertyNames(o).forEach(function (prop) {
        if (hasOwnProp.call(o, prop) &&
            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
            o[prop] !== null &&
            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
            !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
        }
    });
    return o;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State Context factory class
 * @ignore
 */
class InternalStateOperations {
    /**
     * @param {?} _stateStream
     * @param {?} _dispatcher
     * @param {?} _config
     */
    constructor(_stateStream, _dispatcher, _config) {
        this._stateStream = _stateStream;
        this._dispatcher = _dispatcher;
        this._config = _config;
        this.verifyDevMode();
    }
    /**
     * Returns the root state operators.
     * @return {?}
     */
    getRootStateOperations() {
        /** @type {?} */
        const rootStateOperations = {
            getState: () => this._stateStream.getValue(),
            setState: newState => this._stateStream.next(newState),
            dispatch: actions => this._dispatcher.dispatch(actions)
        };
        if (this._config.developmentMode) {
            return this.ensureStateAndActionsAreImmutable(rootStateOperations);
        }
        return rootStateOperations;
    }
    /**
     * @private
     * @return {?}
     */
    verifyDevMode() {
        /** @type {?} */
        const isNgxsDevMode = this._config.developmentMode;
        /** @type {?} */
        const isNgDevMode = isDevMode();
        /** @type {?} */
        const incorrectProduction = !isNgDevMode && isNgxsDevMode;
        /** @type {?} */
        const incorrectDevelopment = isNgDevMode && !isNgxsDevMode;
        /** @type {?} */
        const example = 'NgxsModule.forRoot(states, { developmentMode: !environment.production })';
        if (incorrectProduction) {
            console.warn('Angular is running in production mode but NGXS is still running in the development mode!\n', 'Please set developmentMode to false on the NgxsModule options when in production mode.\n', example);
        }
        else if (incorrectDevelopment) {
            console.warn('RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\n', example);
        }
    }
    /**
     * @private
     * @param {?} root
     * @return {?}
     */
    ensureStateAndActionsAreImmutable(root) {
        return {
            getState: () => root.getState(),
            setState: value => {
                /** @type {?} */
                const frozenValue = deepFreeze(value);
                return root.setState(frozenValue);
            },
            dispatch: actions => {
                return root.dispatch(actions);
            }
        };
    }
}
InternalStateOperations.decorators = [
    { type: Injectable }
];
/** @nocollapse */
InternalStateOperations.ctorParameters = () => [
    { type: StateStream },
    { type: InternalDispatcher },
    { type: NgxsConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State Context factory class
 * @ignore
 */
class StateContextFactory {
    /**
     * @param {?} _internalStateOperations
     */
    constructor(_internalStateOperations) {
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Create the state context
     * @param {?} metadata
     * @return {?}
     */
    createStateContext(metadata) {
        /** @type {?} */
        const root = this._internalStateOperations.getRootStateOperations();
        return {
            /**
             * @return {?}
             */
            getState() {
                /** @type {?} */
                const state = root.getState();
                return getValue(state, metadata.depth);
            },
            /**
             * @param {?} val
             * @return {?}
             */
            patchState(val) {
                /** @type {?} */
                const isArray = Array.isArray(val);
                /** @type {?} */
                const isPrimitive = typeof val !== 'object';
                if (isArray) {
                    throw new Error('Patching arrays is not supported.');
                }
                else if (isPrimitive) {
                    throw new Error('Patching primitives is not supported.');
                }
                /** @type {?} */
                const state = root.getState();
                /** @type {?} */
                const local = getValue(state, metadata.depth);
                /** @type {?} */
                const clone = Object.assign({}, local);
                for (const k in val) {
                    clone[k] = val[k];
                }
                /** @type {?} */
                const newState = setValue(state, metadata.depth, clone);
                root.setState(newState);
                return newState;
            },
            /**
             * @param {?} val
             * @return {?}
             */
            setState(val) {
                /** @type {?} */
                let state = root.getState();
                state = setValue(state, metadata.depth, val);
                root.setState(state);
                return state;
            },
            /**
             * @param {?} actions
             * @return {?}
             */
            dispatch(actions) {
                return root.dispatch(actions);
            }
        };
    }
}
StateContextFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateContextFactory.ctorParameters = () => [
    { type: InternalStateOperations }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State factory class
 * @ignore
 */
class StateFactory {
    /**
     * @param {?} _injector
     * @param {?} _config
     * @param {?} _parentFactory
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _stateContextFactory
     */
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._states = [];
        this._connected = false;
    }
    /**
     * @return {?}
     */
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    /**
     * Add a new state to the global defs.
     * @param {?} oneOrManyStateClasses
     * @return {?}
     */
    add(oneOrManyStateClasses) {
        /** @type {?} */
        let stateClasses;
        if (!Array.isArray(oneOrManyStateClasses)) {
            stateClasses = [oneOrManyStateClasses];
        }
        else {
            stateClasses = oneOrManyStateClasses;
        }
        /** @type {?} */
        const stateGraph = buildGraph(stateClasses);
        /** @type {?} */
        const sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        const depths = findFullParentPath(stateGraph);
        /** @type {?} */
        const nameGraph = nameToState(stateClasses);
        /** @type {?} */
        const mappedStores = [];
        for (const name of sortedStates) {
            /** @type {?} */
            const stateClass = nameGraph[name];
            if (!stateClass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            /** @type {?} */
            const depth = depths[name];
            const { actions } = stateClass[META_KEY];
            let { defaults } = stateClass[META_KEY];
            stateClass[META_KEY].path = depth;
            stateClass[META_KEY].selectFromAppState = propGetter(depth.split('.'), this._config);
            // ensure our store hasn't already been added
            // but dont throw since it could be lazy
            // loaded from different paths
            /** @type {?} */
            const has = this.states.find(s => s.name === name);
            if (!has) {
                // create new instance of defaults
                if (Array.isArray(defaults)) {
                    defaults = [...defaults];
                }
                else if (isObject(defaults)) {
                    defaults = Object.assign({}, defaults);
                }
                else if (defaults === undefined) {
                    defaults = {};
                }
                /** @type {?} */
                const instance = this._injector.get(stateClass);
                mappedStores.push({
                    actions,
                    instance,
                    defaults,
                    name,
                    depth
                });
            }
        }
        this.states.push(...mappedStores);
        return mappedStores;
    }
    /**
     * Add a set of states to the store and return the defaulsts
     * @param {?} stateClasses
     * @return {?}
     */
    addAndReturnDefaults(stateClasses) {
        if (stateClasses) {
            /** @type {?} */
            const states = this.add(stateClasses);
            /** @type {?} */
            const defaults = states.reduce((result, meta) => setValue(result, meta.depth, meta.defaults), {});
            return { defaults, states };
        }
    }
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    connectActionHandlers() {
        if (this._connected)
            return;
        this._actions
            .pipe(filter((ctx) => ctx.status === "DISPATCHED" /* Dispatched */), mergeMap(({ action }) => this.invokeActions(this._actions, action).pipe(map(() => (/** @type {?} */ ({ action, status: "SUCCESSFUL" /* Successful */ }))), defaultIfEmpty((/** @type {?} */ ({ action, status: "CANCELED" /* Canceled */ }))), catchError(error => of((/** @type {?} */ ({ action, status: "ERRORED" /* Errored */, error })))))))
            .subscribe(ctx => this._actionResults.next(ctx));
        this._connected = true;
    }
    /**
     * Invoke the init function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    invokeInit(stateMetadatas) {
        for (const metadata of stateMetadatas) {
            /** @type {?} */
            const instance = metadata.instance;
            if (instance.ngxsOnInit) {
                /** @type {?} */
                const stateContext = this.createStateContext(metadata);
                instance.ngxsOnInit(stateContext);
            }
        }
    }
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    invokeActions(actions$, action) {
        /** @type {?} */
        const results = [];
        for (const metadata of this.states) {
            /** @type {?} */
            const type = getActionTypeFromInstance(action);
            /** @type {?} */
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    /** @type {?} */
                    const stateContext = this.createStateContext(metadata);
                    try {
                        /** @type {?} */
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (result instanceof Observable) {
                            result = result.pipe(actionMeta.options.cancelUncompleted
                                ? takeUntil(actions$.pipe(ofActionDispatched(action)))
                                : map(r => r)); // map acts like a noop
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                }
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    /**
     * Create the state context
     * @private
     * @param {?} metadata
     * @return {?}
     */
    createStateContext(metadata) {
        return this._stateContextFactory.createStateContext(metadata);
    }
}
StateFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateFactory.ctorParameters = () => [
    { type: Injector },
    { type: NgxsConfig },
    { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: StateContextFactory }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function defaultEqualityCheck(a, b) {
    return a === b;
}
/**
 * @param {?} equalityCheck
 * @param {?} prev
 * @param {?} next
 * @return {?}
 */
function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
        return false;
    }
    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
    /** @type {?} */
    const length = prev.length;
    for (let i = 0; i < length; i++) {
        if (!equalityCheck(prev[i], next[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Memoize a function on its last inputs only.
 * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js
 *
 * @ignore
 * @param {?} func
 * @param {?=} equalityCheck
 * @return {?}
 */
function memoize(func, equalityCheck = defaultEqualityCheck) {
    /** @type {?} */
    let lastArgs = null;
    /** @type {?} */
    let lastResult = null;
    // we reference arguments instead of spreading them for performance reasons
    return (/** @type {?} */ (function memoized() {
        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
            // apply arguments instead of spreading for performance.
            lastResult = func.apply(null, arguments);
        }
        lastArgs = arguments;
        return lastResult;
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Function for creating a selector
 * @param {?} selectors The selectors to use to create the arguments of this function
 * @param {?} originalFn The original function being made into a selector
 * @param {?=} creationMetadata
 * @return {?}
 */
function createSelector(selectors, originalFn, creationMetadata) {
    /** @type {?} */
    const wrappedFn = function wrappedSelectorFn(...args) {
        /** @type {?} */
        const returnValue = originalFn(...args);
        if (returnValue instanceof Function) {
            /** @type {?} */
            const innerMemoizedFn = memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    };
    /** @type {?} */
    const memoizedFn = memoize(wrappedFn);
    /** @type {?} */
    const containerClass = creationMetadata && creationMetadata.containerClass;
    /** @type {?} */
    const fn = state => {
        /** @type {?} */
        const results = [];
        /** @type {?} */
        const selectorsToApply = [];
        if (containerClass) {
            // If we are on a state class, add it as the first selector parameter
            /** @type {?} */
            const metadata = getStoreMetadata(containerClass);
            if (metadata) {
                selectorsToApply.push(containerClass);
            }
        }
        if (selectors) {
            selectorsToApply.push(...selectors);
        }
        // Determine arguments from the app state using the selectors
        if (selectorsToApply) {
            results.push(...selectorsToApply.map(a => getSelectorFn(a)(state)));
        }
        // if the lambda tries to access a something on the
        // state that doesn't exist, it will throw a TypeError.
        // since this is quite usual behaviour, we simply return undefined if so.
        try {
            return memoizedFn(...results);
        }
        catch (ex) {
            if (ex instanceof TypeError) {
                return undefined;
            }
            throw ex;
        }
    };
    /** @type {?} */
    const selectorMetaData = ensureSelectorMetadata(memoizedFn);
    selectorMetaData.originalFn = originalFn;
    selectorMetaData.selectFromAppState = fn;
    if (creationMetadata) {
        selectorMetaData.containerClass = creationMetadata.containerClass;
        selectorMetaData.selectorName = creationMetadata.selectorName;
    }
    return memoizedFn;
}
/**
 * This function gets the selector function to be used to get the selected slice from the app state
 * @ignore
 * @param {?} selector
 * @return {?}
 */
function getSelectorFn(selector) {
    /** @type {?} */
    const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
    return (metadata && metadata.selectFromAppState) || selector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Store {
    /**
     * @param {?} _ngZone
     * @param {?} _stateStream
     * @param {?} _internalStateOperations
     */
    constructor(_ngZone, _stateStream, _internalStateOperations) {
        this._ngZone = _ngZone;
        this._stateStream = _stateStream;
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    dispatch(event) {
        return this._internalStateOperations.getRootStateOperations().dispatch(event);
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    select(selector) {
        /** @type {?} */
        const selectorFn = getSelectorFn(selector);
        return this._stateStream.pipe(map(selectorFn), catchError(err => {
            // if error is TypeError we swallow it to prevent usual errors with property access
            if (err instanceof TypeError) {
                return of(undefined);
            }
            // rethrow other errors
            throw err;
        }), distinctUntilChanged(), enterZone(this._ngZone));
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    selectOnce(selector) {
        return this.select(selector).pipe(take(1));
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    selectSnapshot(selector) {
        /** @type {?} */
        const selectorFn = getSelectorFn(selector);
        return selectorFn(this._stateStream.getValue());
    }
    /**
     * Allow the user to subscribe to the root of the state
     * @param {?=} fn
     * @return {?}
     */
    subscribe(fn) {
        return this._stateStream.pipe(enterZone(this._ngZone)).subscribe(fn);
    }
    /**
     * Return the raw value of the state.
     * @return {?}
     */
    snapshot() {
        return this._internalStateOperations.getRootStateOperations().getState();
    }
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     * @param {?} state
     * @return {?}
     */
    reset(state) {
        return this._internalStateOperations.getRootStateOperations().setState(state);
    }
}
Store.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Store.ctorParameters = () => [
    { type: NgZone },
    { type: StateStream },
    { type: InternalStateOperations }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Allows the select decorator to get access to the DI store.
 * @ignore
 */
class SelectFactory {
    /**
     * @param {?} store
     * @param {?} config
     */
    constructor(store, config) {
        SelectFactory.store = store;
        SelectFactory.config = config;
    }
}
SelectFactory.store = undefined;
SelectFactory.config = undefined;
SelectFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SelectFactory.ctorParameters = () => [
    { type: Store },
    { type: NgxsConfig }
];
/**
 * Decorator for selecting a slice of state from the store.
 * @param {?=} selectorOrFeature
 * @param {...?} paths
 * @return {?}
 */
function Select(selectorOrFeature, ...paths) {
    return function (target, name) {
        /** @type {?} */
        const selectorFnName = '__' + name + '__selector';
        if (!selectorOrFeature) {
            // if foo$ => make it just foo
            selectorOrFeature = name.lastIndexOf('$') === name.length - 1 ? name.substring(0, name.length - 1) : name;
        }
        /** @type {?} */
        const createSelect = fn => {
            /** @type {?} */
            const store = SelectFactory.store;
            if (!store) {
                throw new Error('SelectFactory not connected to store!');
            }
            return store.select(fn);
        };
        /** @type {?} */
        const createSelector = () => {
            /** @type {?} */
            const config = SelectFactory.config;
            if (typeof selectorOrFeature === 'string') {
                /** @type {?} */
                const propsArray = paths.length ? [selectorOrFeature, ...paths] : selectorOrFeature.split('.');
                return propGetter(propsArray, config);
            }
            else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {
                return propGetter(selectorOrFeature[META_KEY].path.split('.'), config);
            }
            else {
                return selectorOrFeature;
            }
        };
        if (target[selectorFnName]) {
            throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');
        }
        if (delete target[name]) {
            Object.defineProperty(target, selectorFnName, {
                writable: true,
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(target, name, {
                get: function () {
                    return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this, [createSelector()]));
                },
                enumerable: true,
                configurable: true
            });
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Init action
 */
class InitState {
    /**
     * @return {?}
     */
    static get type() {
        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
        return '@@INIT';
    }
}
/**
 * Update action
 */
class UpdateState {
    /**
     * @return {?}
     */
    static get type() {
        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
        return '@@UPDATE_STATE';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Root module
 * @ignore
 */
class NgxsRootModule {
    /**
     * @param {?} factory
     * @param {?} internalStateOperations
     * @param {?} store
     * @param {?} select
     * @param {?} states
     */
    constructor(factory, internalStateOperations, store, select, states) {
        // add stores to the state graph and return their defaults
        /** @type {?} */
        const results = factory.addAndReturnDefaults(states);
        /** @type {?} */
        const stateOperations = internalStateOperations.getRootStateOperations();
        if (results) {
            // get our current stream
            /** @type {?} */
            const cur = stateOperations.getState();
            // set the state to the current + new
            stateOperations.setState(Object.assign({}, cur, results.defaults));
        }
        // connect our actions stream
        factory.connectActionHandlers();
        // dispatch the init action and invoke init function after
        stateOperations.dispatch(new InitState()).subscribe(() => {
            if (results) {
                factory.invokeInit(results.states);
            }
        });
    }
}
NgxsRootModule.decorators = [
    { type: NgModule }
];
/** @nocollapse */
NgxsRootModule.ctorParameters = () => [
    { type: StateFactory },
    { type: InternalStateOperations },
    { type: Store },
    { type: SelectFactory },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [ROOT_STATE_TOKEN,] }] }
];
/**
 * Feature module
 * @ignore
 */
class NgxsFeatureModule {
    /**
     * @param {?} store
     * @param {?} internalStateOperations
     * @param {?} factory
     * @param {?} states
     */
    constructor(store, internalStateOperations, factory, states) {
        // Since FEATURE_STATE_TOKEN is a multi token, we need to
        // flatten it [[Feature1State, Feature2State], [Feature3State]]
        /** @type {?} */
        const flattenedStates = ((/** @type {?} */ ([]))).concat(...states);
        // add stores to the state graph and return their defaults
        /** @type {?} */
        const results = factory.addAndReturnDefaults(flattenedStates);
        /** @type {?} */
        const stateOperations = internalStateOperations.getRootStateOperations();
        if (results) {
            // get our current stream
            /** @type {?} */
            const cur = stateOperations.getState();
            // set the state to the current + new
            stateOperations.setState(Object.assign({}, cur, results.defaults));
        }
        stateOperations.dispatch(new UpdateState()).subscribe(() => {
            if (results) {
                factory.invokeInit(results.states);
            }
        });
    }
}
NgxsFeatureModule.decorators = [
    { type: NgModule, args: [{},] }
];
/** @nocollapse */
NgxsFeatureModule.ctorParameters = () => [
    { type: Store },
    { type: InternalStateOperations },
    { type: StateFactory },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [FEATURE_STATE_TOKEN,] }] }
];
/**
 * @param {?} options
 * @return {?}
 */
function ngxsConfigFactory(options) {
    /** @type {?} */
    const config = Object.assign(new NgxsConfig(), options);
    return config;
}
/** @type {?} */
const ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');
/**
 * Ngxs Module
 */
class NgxsModule {
    /**
     * Root module factory
     * @param {?=} states
     * @param {?=} options
     * @return {?}
     */
    static forRoot(states = [], options = {}) {
        return {
            ngModule: NgxsRootModule,
            providers: [
                StateFactory,
                StateContextFactory,
                Actions,
                InternalActions,
                InternalDispatcher,
                InternalDispatchedActionResults,
                InternalStateOperations,
                Store,
                StateStream,
                SelectFactory,
                PluginManager,
                ...states,
                {
                    provide: ROOT_STATE_TOKEN,
                    useValue: states
                },
                {
                    provide: ROOT_OPTIONS,
                    useValue: options
                },
                {
                    provide: NgxsConfig,
                    useFactory: ngxsConfigFactory,
                    deps: [ROOT_OPTIONS]
                }
            ]
        };
    }
    /**
     * Feature module factory
     * @param {?} states
     * @return {?}
     */
    static forFeature(states) {
        return {
            ngModule: NgxsFeatureModule,
            providers: [
                StateFactory,
                PluginManager,
                ...states,
                {
                    provide: FEATURE_STATE_TOKEN,
                    multi: true,
                    useValue: states
                }
            ]
        };
    }
}
NgxsModule.decorators = [
    { type: NgModule, args: [{},] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorates a method with a action information.
 * @param {?} actions
 * @param {?=} options
 * @return {?}
 */
function Action(actions, options) {
    return function (target, name, descriptor) {
        /** @type {?} */
        const meta = ensureStoreMetadata(target.constructor);
        if (!Array.isArray(actions)) {
            actions = [actions];
        }
        for (const action of actions) {
            /** @type {?} */
            const type = action.type;
            if (!action.type) {
                throw new Error(`Action ${action.name} is missing a static "type" property`);
            }
            if (!meta.actions[type]) {
                meta.actions[type] = [];
            }
            meta.actions[type].push({
                fn: name,
                options: options || {},
                type
            });
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');
/**
 * Error message
 * @ignore
 * @type {?}
 */
const stateNameErrorMessage = name => `${name} is not a valid state name. It needs to be a valid object property name.`;
/**
 * Decorates a class with ngxs state information.
 * @template T
 * @param {?} options
 * @return {?}
 */
function State(options) {
    return function (target) {
        /** @type {?} */
        const meta = ensureStoreMetadata(target);
        // Handle inheritance
        if (Object.getPrototypeOf(target).hasOwnProperty(META_KEY)) {
            /** @type {?} */
            const parentMeta = Object.getPrototypeOf(target)[META_KEY];
            meta.actions = Object.assign({}, meta.actions, parentMeta.actions);
        }
        meta.children = options.children;
        meta.defaults = options.defaults;
        meta.name = options.name;
        if (!options.name) {
            throw new Error(`States must register a 'name' property`);
        }
        if (!stateNameRegex.test(options.name)) {
            throw new Error(stateNameErrorMessage(options.name));
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorator for memoizing a state selector.
 * @param {?=} selectors
 * @return {?}
 */
function Selector(selectors) {
    return (target, key, descriptor) => {
        if (descriptor.value !== null) {
            /** @type {?} */
            const originalFn = descriptor.value;
            /** @type {?} */
            const memoizedFn = createSelector(selectors, originalFn, { containerClass: target, selectorName: key });
            return {
                configurable: true,
                /**
                 * @return {?}
                 */
                get() {
                    return memoizedFn;
                }
            };
        }
        else {
            throw new Error('Selectors only work on methods');
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxsModule, Action, Store, State, Select, Actions, getSelectorMetadata, getStoreMetadata, ensureStoreMetadata, ensureSelectorMetadata, ofAction, ofActionDispatched, ofActionSuccessful, ofActionCanceled, ofActionErrored, Selector, getActionTypeFromInstance, actionMatcher, createSelector, NGXS_PLUGINS, StateStream, setValue, getValue, InitState, UpdateState, InternalActions as g, OrderedSubject as f, SelectFactory as e, InternalDispatchedActionResults as n, InternalDispatcher as o, StateContextFactory as p, StateFactory as m, InternalStateOperations as q, NgxsFeatureModule as b, NgxsRootModule as a, ROOT_OPTIONS as d, ngxsConfigFactory as c, PluginManager as r, FEATURE_STATE_TOKEN as i, META_KEY as j, NgxsConfig as l, ROOT_STATE_TOKEN as h, SELECTOR_META_KEY as k };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4cy1zdG9yZS5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQG5neHMvc3RvcmUvc3JjL3N5bWJvbHMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9pbnRlcm5hbHMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy91dGlscy91dGlscy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL29wZXJhdG9ycy9vZi1hY3Rpb24udHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9vcGVyYXRvcnMvem9uZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2FjdGlvbnMtc3RyZWFtLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvY29tcG9zZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLXN0cmVhbS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3BsdWdpbi1tYW5hZ2VyLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvaW50ZXJuYWwvZGlzcGF0Y2hlci50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3V0aWxzL2ZyZWV6ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnkudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1mYWN0b3J5LnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvbWVtb2l6ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3V0aWxzL3NlbGVjdG9yLXV0aWxzLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvc3RvcmUudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9kZWNvcmF0b3JzL3NlbGVjdC50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2FjdGlvbnMvYWN0aW9ucy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL21vZHVsZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2RlY29yYXRvcnMvYWN0aW9uLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvZGVjb3JhdG9ycy9zdGF0ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2RlY29yYXRvcnMvc2VsZWN0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFJPT1RfU1RBVEVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48YW55PignUk9PVF9TVEFURV9UT0tFTicpO1xyXG5leHBvcnQgY29uc3QgRkVBVFVSRV9TVEFURV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KCdGRUFUVVJFX1NUQVRFX1RPS0VOJyk7XHJcbmV4cG9ydCBjb25zdCBNRVRBX0tFWSA9ICdOR1hTX01FVEEnO1xyXG5leHBvcnQgY29uc3QgU0VMRUNUT1JfTUVUQV9LRVkgPSAnTkdYU19TRUxFQ1RPUl9NRVRBJztcclxuXHJcbmV4cG9ydCBjb25zdCBOR1hTX1BMVUdJTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05HWFNfUExVR0lOUycpO1xyXG5leHBvcnQgdHlwZSBOZ3hzUGx1Z2luQ29uc3RydWN0b3IgPSBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBOZ3hzUGx1Z2luO1xyXG5leHBvcnQgdHlwZSBOZ3hzUGx1Z2luRm4gPSAoc3RhdGU6IGFueSwgbXV0YXRpb246IGFueSwgbmV4dDogTmd4c05leHRQbHVnaW5GbikgPT4gYW55O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBOR1hTIGNvbmZpZyBzZXR0aW5ncy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZ3hzQ29uZmlnIHtcclxuICAvKipcclxuICAgKiBSdW4gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gVGhpcyB3aWxsIGFkZCBhZGRpdGlvbmFsIGRlYnVnZ2luZyBmZWF0dXJlczpcclxuICAgKiAtIE9iamVjdC5mcmVlemUgb24gdGhlIHN0YXRlIGFuZCBhY3Rpb25zIHRvIGd1YXJhbnRlZSBpbW11dGFiaWxpdHlcclxuICAgKiAoZGVmYXVsdDogZmFsc2UpXHJcbiAgICovXHJcbiAgZGV2ZWxvcG1lbnRNb2RlOiBib29sZWFuO1xyXG4gIGNvbXBhdGliaWxpdHk6IHtcclxuICAgIC8qKlxyXG4gICAgICogU3VwcG9ydCBhIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cclxuICAgICAqIFRoaXMgd2lsbCBjaXJ1bXZlbnQgc29tZSBvcHRpbWlzYXRpb25zIHRoYXQgdmlvbGF0ZSBhIHN0cmljdCBDU1AgdGhyb3VnaCB0aGUgdXNlIG9mIGBuZXcgRnVuY3Rpb24oLi4uKWAuXHJcbiAgICAgKiAoZGVmYXVsdDogZmFsc2UpXHJcbiAgICAgKi9cclxuICAgIHN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeTogYm9vbGVhbjtcclxuICB9O1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY29tcGF0aWJpbGl0eSA9IHtcclxuICAgICAgc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5OiBmYWxzZVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBjb250ZXh0IHByb3ZpZGVkIHRvIHRoZSBhY3Rpb25zIGluIHRoZSBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVDb250ZXh0PFQ+IHtcclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAgICovXHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldFN0YXRlKHZhbDogVCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGNoIHRoZSBleGlzdGluZyBzdGF0ZSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgKi9cclxuICBwYXRjaFN0YXRlKHZhbDogUGFydGlhbDxUPik7XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoIGEgbmV3IGFjdGlvbiBhbmQgcmV0dXJuIHRoZSBkaXNwYXRjaGVkIG9ic2VydmFibGUuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzTmV4dFBsdWdpbkZuID0gKHN0YXRlOiBhbnksIG11dGF0aW9uOiBhbnkpID0+IGFueTtcclxuXHJcbi8qKlxyXG4gKiBQbHVnaW4gaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNQbHVnaW4ge1xyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSB0aGUgc3RhdGUvYWN0aW9uIGJlZm9yZSBpdHMgc3VibWl0dGVkIHRvIHRoZSBzdGF0ZSBoYW5kbGVycy5cclxuICAgKi9cclxuICBoYW5kbGUoc3RhdGU6IGFueSwgYWN0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pOiBhbnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIHRoYXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBzdG9yZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmVPcHRpb25zPFQ+IHtcclxuICAvKipcclxuICAgKiBOYW1lIG9mIHRoZSBzdGF0ZS4gUmVxdWlyZWQuXHJcbiAgICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgdGhlIHN0YXRlLiBJZiBub3QgcHJvdmlkZWQsIHVzZXMgZW1wdHkgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGRlZmF1bHRzPzogVDtcclxuXHJcbiAgLyoqXHJcbiAgICogU3ViIHN0YXRlcyBmb3IgdGhlIGdpdmVuIHN0YXRlLlxyXG4gICAqL1xyXG4gIGNoaWxkcmVuPzogYW55W107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBY3Rpb25zIHRoYXQgY2FuIGJlIHByb3ZpZGVkIGluIGEgYWN0aW9uIGRlY29yYXRvci5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uT3B0aW9ucyB7XHJcbiAgLyoqXHJcbiAgICogQ2FuY2VsIHRoZSBwcmV2aW91cyB1bmNvbXBsZXRlZCBvYnNlcnZhYmxlKHMpLlxyXG4gICAqL1xyXG4gIGNhbmNlbFVuY29tcGxldGVkPzogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIE9uIGluaXQgaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNPbkluaXQge1xyXG4gIG5neHNPbkluaXQoY3R4PzogU3RhdGVDb250ZXh0PGFueT4pOiB2b2lkIHwgYW55O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzTGlmZUN5Y2xlID0gUGFydGlhbDxOZ3hzT25Jbml0PjtcclxuIiwiaW1wb3J0IHsgTUVUQV9LRVksIEFjdGlvbk9wdGlvbnMsIFNFTEVDVE9SX01FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0S2V5TWFwPFQ+IHtcclxuICBba2V5OiBzdHJpbmddOiBUO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ2xhc3Mge1xyXG4gIFtNRVRBX0tFWV0/OiBNZXRhRGF0YU1vZGVsO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTdGF0ZUtleUdyYXBoID0gT2JqZWN0S2V5TWFwPHN0cmluZ1tdPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uSGFuZGxlck1ldGFEYXRhIHtcclxuICBmbjogc3RyaW5nO1xyXG4gIG9wdGlvbnM6IEFjdGlvbk9wdGlvbnM7XHJcbiAgdHlwZTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlT3BlcmF0aW9uczxUPiB7XHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuICBzZXRTdGF0ZSh2YWw6IFQpO1xyXG4gIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXRhRGF0YU1vZGVsIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgYWN0aW9uczogT2JqZWN0S2V5TWFwPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIHBhdGg6IHN0cmluZztcclxuICBzZWxlY3RGcm9tQXBwU3RhdGU6IFNlbGVjdEZyb21TdGF0ZTtcclxuICBjaGlsZHJlbjogU3RhdGVDbGFzc1tdO1xyXG4gIGluc3RhbmNlOiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNlbGVjdEZyb21TdGF0ZSA9IChzdGF0ZTogYW55KSA9PiBhbnk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgc2VsZWN0RnJvbUFwcFN0YXRlOiBTZWxlY3RGcm9tU3RhdGU7XHJcbiAgb3JpZ2luYWxGbjogRnVuY3Rpb247XHJcbiAgY29udGFpbmVyQ2xhc3M6IGFueTtcclxuICBzZWxlY3Rvck5hbWU6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXBwZWRTdG9yZSB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGFjdGlvbnM6IE9iamVjdEtleU1hcDxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBpbnN0YW5jZTogYW55O1xyXG4gIGRlcHRoOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBjbGFzcyBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0KTogTWV0YURhdGFNb2RlbCB7XHJcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoTUVUQV9LRVkpKSB7XHJcbiAgICBjb25zdCBkZWZhdWx0TWV0YWRhdGE6IE1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgIGFjdGlvbnM6IHt9LFxyXG4gICAgICBkZWZhdWx0czoge30sXHJcbiAgICAgIHBhdGg6IG51bGwsXHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICBpbnN0YW5jZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBNRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuICByZXR1cm4gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtZXRhZGF0YSBhdHRhY2hlZCB0byB0aGUgY2xhc3MgaWYgaXQgZXhpc3RzLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQpOiBNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W01FVEFfS0VZXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZXMgbWV0YWRhdGEgaXMgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGFuZCByZXR1cm5zIGl0LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQpOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KFNFTEVDVE9SX01FVEFfS0VZKSkge1xyXG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgb3JpZ2luYWxGbjogbnVsbCxcclxuICAgICAgY29udGFpbmVyQ2xhc3M6IG51bGwsXHJcbiAgICAgIHNlbGVjdG9yTmFtZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBTRUxFQ1RPUl9NRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W1NFTEVDVE9SX01FVEFfS0VZXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCBhcyBmYXN0IGFzIHRoZSBgZmFzdFByb3BHZXR0ZXJgIGJ1dCBpcyBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgY29tcGxpYW50LlxyXG4gKiBTZWUgcGVyZiBoaXQ6IGh0dHBzOi8vanNwZXJmLmNvbS9mYXN0LXZhbHVlLWdldHRlci1naXZlbi1wYXRoLzFcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGxpYW50UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xyXG4gIGNvbnN0IGNvcHlPZlBhdGhzID0gWy4uLnBhdGhzXTtcclxuICByZXR1cm4gb2JqID0+IGNvcHlPZlBhdGhzLnJlZHVjZSgoYWNjOiBhbnksIHBhcnQ6IHN0cmluZykgPT4gYWNjICYmIGFjY1twYXJ0XSwgb2JqKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW46XHJcbiAqIC0gcGx1Y2sgKE9ic2VydmFibGUgb3BlcmF0b3IpXHJcbiAqIC0gbWVtb2l6ZVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBmYXN0UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xyXG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aHM7XHJcbiAgbGV0IHNlZyA9ICdzdG9yZS4nICsgc2VnbWVudHNbMF07XHJcbiAgbGV0IGkgPSAwO1xyXG4gIGNvbnN0IGwgPSBzZWdtZW50cy5sZW5ndGg7XHJcblxyXG4gIGxldCBleHByID0gc2VnO1xyXG4gIHdoaWxlICgrK2kgPCBsKSB7XHJcbiAgICBleHByID0gZXhwciArICcgJiYgJyArIChzZWcgPSBzZWcgKyAnLicgKyBzZWdtZW50c1tpXSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbignc3RvcmUnLCAncmV0dXJuICcgKyBleHByICsgJzsnKTtcclxuXHJcbiAgcmV0dXJuIDwoeDogYW55KSA9PiBhbnk+Zm47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdLCBjb25maWc6IE5neHNDb25maWcpIHtcclxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5jb21wYXRpYmlsaXR5ICYmIGNvbmZpZy5jb21wYXRpYmlsaXR5LnN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeSkge1xyXG4gICAgcmV0dXJuIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZmFzdFByb3BHZXR0ZXIocGF0aHMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHN0YXRlcywgaXQgd2lsbCByZXR1cm4gYSBvYmplY3QgZ3JhcGguIEV4YW1wbGU6XHJcbiAqICAgIGNvbnN0IHN0YXRlcyA9IFtcclxuICogICAgICBDYXJ0LFxyXG4gKiAgICAgIENhcnRTYXZlZCxcclxuICogICAgICBDYXJ0U2F2ZWRJdGVtc1xyXG4gKiAgICBdXHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR3JhcGgoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW10pOiBTdGF0ZUtleUdyYXBoIHtcclxuICBjb25zdCBmaW5kTmFtZSA9IChzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc2VzLmZpbmQoZyA9PiBnID09PSBzdGF0ZUNsYXNzKTtcclxuICAgIGlmICghbWV0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlIG5vdCBmb3VuZDogJHtzdGF0ZUNsYXNzfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbWV0YVtNRVRBX0tFWV0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZXMgbXVzdCBiZSBkZWNvcmF0ZWQgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3InKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWV0YVtNRVRBX0tFWV0ubmFtZTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc3RhdGVDbGFzc2VzLnJlZHVjZTxTdGF0ZUtleUdyYXBoPigocmVzdWx0OiBTdGF0ZUtleUdyYXBoLCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICBpZiAoIXN0YXRlQ2xhc3NbTUVUQV9LRVldKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGVzIG11c3QgYmUgZGVjb3JhdGVkIHdpdGggQFN0YXRlKCkgZGVjb3JhdG9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBuYW1lLCBjaGlsZHJlbiB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcbiAgICByZXN1bHRbbmFtZV0gPSAoY2hpbGRyZW4gfHwgW10pLm1hcChmaW5kTmFtZSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgc3RhdGVzIGFycmF5LCByZXR1cm5zIG9iamVjdCBncmFwaFxyXG4gKiByZXR1cm5pbmcgdGhlIG5hbWUgYW5kIHN0YXRlIG1ldGFkYXRhLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IHsgbWV0YWRhdGEgfVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVUb1N0YXRlKHN0YXRlczogU3RhdGVDbGFzc1tdKTogT2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3M+IHtcclxuICByZXR1cm4gc3RhdGVzLnJlZHVjZTxPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz4+KChyZXN1bHQ6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiwgc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgaWYgKCFzdGF0ZUNsYXNzW01FVEFfS0VZXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlcyBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXTtcclxuICAgIHJlc3VsdFttZXRhLm5hbWVdID0gc3RhdGVDbGFzcztcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSwge30pO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBvYmplY3QgcmVsYXRpb25zaGlwIGdyYXBoIHdpbGwgcmV0dXJuIHRoZSBmdWxsIHBhdGhcclxuICogZm9yIHRoZSBjaGlsZCBpdGVtcy4gRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogd291bGQgcmV0dXJuOlxyXG4gKlxyXG4gKiAgY29uc3QgciA9IHtcclxuICogICAgY2FydDogJ2NhcnQnLFxyXG4gKiAgICBzYXZlZDogJ2NhcnQuc2F2ZWQnLFxyXG4gKiAgICBpdGVtczogJ2NhcnQuc2F2ZWQuaXRlbXMnXHJcbiAqICB9O1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZ1bGxQYXJlbnRQYXRoKG9iajogU3RhdGVLZXlHcmFwaCwgbmV3T2JqOiBPYmplY3RLZXlNYXA8c3RyaW5nPiA9IHt9KTogT2JqZWN0S2V5TWFwPHN0cmluZz4ge1xyXG4gIGNvbnN0IHZpc2l0ID0gKGNoaWxkOiBTdGF0ZUtleUdyYXBoLCBrZXlUb0ZpbmQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZCkge1xyXG4gICAgICBpZiAoY2hpbGQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjaGlsZFtrZXldLmluZGV4T2Yoa2V5VG9GaW5kKSA+PSAwKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQoY2hpbGQsIGtleSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQob2JqLCBrZXkpO1xyXG4gICAgICBuZXdPYmpba2V5XSA9IHBhcmVudCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXdPYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIG9iamVjdCBncmFwaCwgaXQgd2lsbCByZXR1cm4gdGhlIGl0ZW1zIHRvcG9sb2dpY2FsbHkgc29ydGVkIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHJlc3VsdHMgPSBbXHJcbiAqICAgICdpdGVtcycsXHJcbiAqICAgICdzYXZlZCcsXHJcbiAqICAgICdjYXJ0J1xyXG4gKiAgXTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvcG9sb2dpY2FsU29ydChncmFwaDogU3RhdGVLZXlHcmFwaCk6IHN0cmluZ1tdIHtcclxuICBjb25zdCBzb3J0ZWQ6IHN0cmluZ1tdID0gW107XHJcbiAgY29uc3QgdmlzaXRlZDogT2JqZWN0S2V5TWFwPGJvb2xlYW4+ID0ge307XHJcblxyXG4gIGNvbnN0IHZpc2l0ID0gKG5hbWU6IHN0cmluZywgYW5jZXN0b3JzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYW5jZXN0b3JzKSkge1xyXG4gICAgICBhbmNlc3RvcnMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBhbmNlc3RvcnMucHVzaChuYW1lKTtcclxuICAgIHZpc2l0ZWRbbmFtZV0gPSB0cnVlO1xyXG5cclxuICAgIGdyYXBoW25hbWVdLmZvckVhY2goKGRlcDogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGlmIChhbmNlc3RvcnMuaW5kZXhPZihkZXApID49IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENpcmN1bGFyIGRlcGVuZGVuY3kgJyR7ZGVwfScgaXMgcmVxdWlyZWQgYnkgJyR7bmFtZX0nOiAke2FuY2VzdG9ycy5qb2luKCcgLT4gJyl9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2aXNpdGVkW2RlcF0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZpc2l0KGRlcCwgYW5jZXN0b3JzLnNsaWNlKDApKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChzb3J0ZWQuaW5kZXhPZihuYW1lKSA8IDApIHtcclxuICAgICAgc29ydGVkLnB1c2gobmFtZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgT2JqZWN0LmtleXMoZ3JhcGgpLmZvckVhY2goayA9PiB2aXNpdChrKSk7XHJcblxyXG4gIHJldHVybiBzb3J0ZWQucmV2ZXJzZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgb2JqZWN0IG9yIG5vdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xyXG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0eXBlIGZyb20gYW4gYWN0aW9uIGluc3RhbmNlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb246IGFueSk6IHN0cmluZyB7XHJcbiAgaWYgKGFjdGlvbi5jb25zdHJ1Y3RvciAmJiBhY3Rpb24uY29uc3RydWN0b3IudHlwZSkge1xyXG4gICAgcmV0dXJuIGFjdGlvbi5jb25zdHJ1Y3Rvci50eXBlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFjdGlvbi50eXBlO1xyXG59XHJcblxyXG4vKipcclxuICogTWF0Y2hlcyBhIGFjdGlvblxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWN0aW9uTWF0Y2hlcihhY3Rpb24xOiBhbnkpIHtcclxuICBjb25zdCB0eXBlMSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uMSk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbihhY3Rpb24yOiBhbnkpIHtcclxuICAgIHJldHVybiB0eXBlMSA9PT0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24yKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICBzZXRWYWx1ZSh7IGZvbzogeyBiYXI6IHsgZWF0OiBmYWxzZSB9IH0gfSxcclxuICogICAgICAnZm9vLmJhci5lYXQnLCB0cnVlKSAvLz0+IHsgZm9vOiB7IGJhcjogeyBlYXQ6IHRydWUgfSB9IH1cclxuICpcclxuICogV2hpbGUgaXQgdHJhdmVyc2VzIGl0IGFsc28gY3JlYXRlcyBuZXcgb2JqZWN0cyBmcm9tIHRvcCBkb3duLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2V0VmFsdWUgPSAob2JqOiBhbnksIHByb3A6IHN0cmluZywgdmFsOiBhbnkpID0+IHtcclxuICBvYmogPSB7IC4uLm9iaiB9O1xyXG5cclxuICBjb25zdCBzcGxpdCA9IHByb3Auc3BsaXQoJy4nKTtcclxuICBjb25zdCBsYXN0SW5kZXggPSBzcGxpdC5sZW5ndGggLSAxO1xyXG5cclxuICBzcGxpdC5yZWR1Y2UoKGFjYywgcGFydCwgaW5kZXgpID0+IHtcclxuICAgIGlmIChpbmRleCA9PT0gbGFzdEluZGV4KSB7XHJcbiAgICAgIGFjY1twYXJ0XSA9IHZhbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFjY1twYXJ0XSA9IEFycmF5LmlzQXJyYXkoYWNjW3BhcnRdKSA/IFsuLi5hY2NbcGFydF1dIDogeyAuLi5hY2NbcGFydF0gfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWNjICYmIGFjY1twYXJ0XTtcclxuICB9LCBvYmopO1xyXG5cclxuICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0VmFsdWUgPSAob2JqOiBhbnksIHByb3A6IHN0cmluZykgPT5cclxuICBwcm9wLnNwbGl0KCcuJykucmVkdWNlKChhY2M6IGFueSwgcGFydDogc3RyaW5nKSA9PiBhY2MgJiYgYWNjW3BhcnRdLCBvYmopO1xyXG4iLCJpbXBvcnQgeyBPcGVyYXRvckZ1bmN0aW9uLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCwgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBBY3Rpb25Db250ZXh0LCBBY3Rpb25TdGF0dXMgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb248VD4oYWxsb3dlZFR5cGUpOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD47XHJcbmV4cG9ydCBmdW5jdGlvbiBvZkFjdGlvbjxUPiguLi5hbGxvd2VkVHlwZXMpOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD47XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IGJlZW4gZGlzcGF0Y2hlZCBhcyB3ZWxsIGFzIGFjdGlvbnMgdGhhdCBoYXZlIGNvbXBsZXRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMpO1xyXG59XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgT05MWSBncmFiIGFjdGlvbnMgdGhhdCBoYXZlIGp1c3QgYmVlbiBkaXNwYXRjaGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25EaXNwYXRjaGVkKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMsIEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ4SlMgb3BlcmF0b3IgZm9yIHNlbGVjdGluZyBvdXQgc3BlY2lmaWMgYWN0aW9ucy5cclxuICpcclxuICogVGhpcyB3aWxsIE9OTFkgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IGJlZW4gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uU3VjY2Vzc2Z1bCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSeEpTIG9wZXJhdG9yIGZvciBzZWxlY3Rpbmcgb3V0IHNwZWNpZmljIGFjdGlvbnMuXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCBPTkxZIGdyYWIgYWN0aW9ucyB0aGF0IGhhdmUganVzdCBiZWVuIGNhbmNlbGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25DYW5jZWxlZCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgT05MWSBncmFiIGFjdGlvbnMgdGhhdCBoYXZlIGp1c3QgdGhyb3duIGFuIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25FcnJvcmVkKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMsIEFjdGlvblN0YXR1cy5FcnJvcmVkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXM6IGFueVtdLCBzdGF0dXM/OiBBY3Rpb25TdGF0dXMpIHtcclxuICBjb25zdCBhbGxvd2VkTWFwID0gY3JlYXRlQWxsb3dlZE1hcChhbGxvd2VkVHlwZXMpO1xyXG4gIHJldHVybiBmdW5jdGlvbihvOiBPYnNlcnZhYmxlPGFueT4pIHtcclxuICAgIHJldHVybiBvLnBpcGUoXHJcbiAgICAgIGZpbHRlclN0YXR1cyhhbGxvd2VkTWFwLCBzdGF0dXMpLFxyXG4gICAgICBtYXBBY3Rpb24oKVxyXG4gICAgKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJTdGF0dXMoYWxsb3dlZFR5cGVzOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSwgc3RhdHVzPzogQWN0aW9uU3RhdHVzKSB7XHJcbiAgcmV0dXJuIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCBhY3Rpb25UeXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShjdHguYWN0aW9uKTtcclxuICAgIGNvbnN0IHR5cGUgPSBhbGxvd2VkVHlwZXNbYWN0aW9uVHlwZV07XHJcbiAgICByZXR1cm4gc3RhdHVzID8gdHlwZSAmJiBjdHguc3RhdHVzID09PSBzdGF0dXMgOiB0eXBlO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBBY3Rpb24oKSB7XHJcbiAgcmV0dXJuIG1hcCgoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguYWN0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQWxsb3dlZE1hcCh0eXBlczogYW55W10pOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSB7XHJcbiAgcmV0dXJuIHR5cGVzLnJlZHVjZSgoYWNjOiBhbnksIGtsYXNzOiBhbnkpID0+IHtcclxuICAgIGFjY1tnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGtsYXNzKV0gPSB0cnVlO1xyXG4gICAgcmV0dXJuIGFjYztcclxuICB9LCB7fSk7XHJcbn1cclxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vKipcclxuICogT3BlcmF0b3IgdG8gcnVuIHRoZSBgc3Vic2NyaWJlYCBpbiBhIEFuZ3VsYXIgem9uZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnRlclpvbmU8VD4oem9uZTogTmdab25lKSB7XHJcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHtcclxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgoc2luazogT2JzZXJ2ZXI8VD4pID0+IHtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoe1xyXG4gICAgICAgIG5leHQoeCkge1xyXG4gICAgICAgICAgem9uZS5ydW4oKCkgPT4gc2luay5uZXh0KHgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yKGUpIHtcclxuICAgICAgICAgIHpvbmUucnVuKCgpID0+IHNpbmsuZXJyb3IoZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGxldGUoKSB7XHJcbiAgICAgICAgICB6b25lLnJ1bigoKSA9PiBzaW5rLmNvbXBsZXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgeyBlbnRlclpvbmUgfSBmcm9tICcuL29wZXJhdG9ycy96b25lJztcclxuXHJcbi8qKlxyXG4gKiBTdGF0dXMgb2YgYSBkaXNwYXRjaGVkIGFjdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVudW0gQWN0aW9uU3RhdHVzIHtcclxuICBEaXNwYXRjaGVkID0gJ0RJU1BBVENIRUQnLFxyXG4gIFN1Y2Nlc3NmdWwgPSAnU1VDQ0VTU0ZVTCcsXHJcbiAgQ2FuY2VsZWQgPSAnQ0FOQ0VMRUQnLFxyXG4gIEVycm9yZWQgPSAnRVJST1JFRCdcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25Db250ZXh0IHtcclxuICBzdGF0dXM6IEFjdGlvblN0YXR1cztcclxuICBhY3Rpb246IGFueTtcclxuICBlcnJvcj86IEVycm9yO1xyXG59XHJcblxyXG4vKipcclxuICogQ3VzdG9tIFN1YmplY3QgdGhhdCBlbnN1cmVzIHRoYXQgc3Vic2NyaWJlcnMgYXJlIG5vdGlmaWVkIG9mIHZhbHVlcyBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFycml2ZWQuXHJcbiAqIEEgc3RhbmRhcmQgU3ViamVjdCBkb2VzIG5vdCBoYXZlIHRoaXMgZ3VhcmFudGVlLlxyXG4gKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGZvbGxvd2luZyBjb2RlOlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqICAgY29uc3Qgc3ViamVjdCA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcclxuICAgICBzdWJqZWN0LnN1YnNjcmliZSh2YWx1ZSA9PiB7XHJcbiAgICAgICBpZiAodmFsdWUgPT09ICdzdGFydCcpIHN1YmplY3QubmV4dCgnZW5kJyk7XHJcbiAgICAgfSk7XHJcbiAgICAgc3ViamVjdC5zdWJzY3JpYmUodmFsdWUgPT4geyB9KTtcclxuICAgICBzdWJqZWN0Lm5leHQoJ3N0YXJ0Jyk7XHJcbiAqIGBgYFxyXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIHN0YW5kYXJkIGBTdWJqZWN0PFQ+YCB0aGUgc2Vjb25kIHN1YnNjcmliZXIgd291bGQgcmVjaWV2ZSBgZW5kYCBhbmQgdGhlbiBgc3RhcnRgLlxyXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIGBPcmRlcmVkU3ViamVjdDxUPmAgdGhlIHNlY29uZCBzdWJzY3JpYmVyIHdvdWxkIHJlY2lldmUgYHN0YXJ0YCBhbmQgdGhlbiBgZW5kYC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBPcmRlcmVkU3ViamVjdDxUPiBleHRlbmRzIFN1YmplY3Q8VD4ge1xyXG4gIHByaXZhdGUgX2l0ZW1RdWV1ZTogVFtdID0gW107XHJcbiAgcHJpdmF0ZSBfYnVzeVB1c2hpbmdOZXh0ID0gZmFsc2U7XHJcblxyXG4gIG5leHQodmFsdWU/OiBUKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fYnVzeVB1c2hpbmdOZXh0KSB7XHJcbiAgICAgIHRoaXMuX2l0ZW1RdWV1ZS51bnNoaWZ0KHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYnVzeVB1c2hpbmdOZXh0ID0gdHJ1ZTtcclxuICAgIHN1cGVyLm5leHQodmFsdWUpO1xyXG4gICAgd2hpbGUgKHRoaXMuX2l0ZW1RdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHRoaXMuX2l0ZW1RdWV1ZS5wb3AoKTtcclxuICAgICAgc3VwZXIubmV4dChuZXh0VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYnVzeVB1c2hpbmdOZXh0ID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgQWN0aW9uIHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgYW55dGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEludGVybmFsQWN0aW9ucyBleHRlbmRzIE9yZGVyZWRTdWJqZWN0PEFjdGlvbkNvbnRleHQ+IHt9XHJcblxyXG4vKipcclxuICogQWN0aW9uIHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgYW55dGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cclxuICpcclxuICogWW91IGNhbiBsaXN0ZW4gdG8gdGhpcyBpbiBzZXJ2aWNlcyB0byByZWFjdCB3aXRob3V0IHN0b3Jlcy5cclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEFjdGlvbnMgZXh0ZW5kcyBPYnNlcnZhYmxlPGFueT4ge1xyXG4gIGNvbnN0cnVjdG9yKGFjdGlvbnMkOiBJbnRlcm5hbEFjdGlvbnMsIG5nWm9uZTogTmdab25lKSB7XHJcbiAgICBzdXBlcihvYnNlcnZlciA9PiB7XHJcbiAgICAgIGFjdGlvbnMkXHJcbiAgICAgICAgLnBpcGUoZW50ZXJab25lKG5nWm9uZSkpXHJcbiAgICAgICAgLnN1YnNjcmliZShyZXMgPT4gb2JzZXJ2ZXIubmV4dChyZXMpLCBlcnIgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSwgKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvbXBvc2VzIGEgYXJyYXkgb2YgZnVuY3Rpb25zIGZyb20gbGVmdCB0byByaWdodC4gRXhhbXBsZTpcclxuICpcclxuICogICAgICBjb21wb3NlKFtmbiwgZmluYWxdKShzdGF0ZSwgYWN0aW9uKTtcclxuICpcclxuICogdGhlbiB0aGUgZnVuY3MgaGF2ZSBhIHNpZ25hdHVyZSBsaWtlOlxyXG4gKlxyXG4gKiAgICAgIGZ1bmN0aW9uIGZuIChzdGF0ZSwgYWN0aW9uLCBuZXh0KSB7XHJcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKCdoZXJlJywgc3RhdGUsIGFjdGlvbiwgbmV4dCk7XHJcbiAqICAgICAgICAgIHJldHVybiBuZXh0KHN0YXRlLCBhY3Rpb24pO1xyXG4gKiAgICAgIH1cclxuICpcclxuICogICAgICBmdW5jdGlvbiBmaW5hbCAoc3RhdGUsIGFjdGlvbikge1xyXG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnaGVyZScsIHN0YXRlLCBhY3Rpb24pO1xyXG4gKiAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAqICAgICAgfVxyXG4gKlxyXG4gKiB0aGUgbGFzdCBmdW5jdGlvbiBzaG91bGQgbm90IGNhbGwgYG5leHRgLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29tcG9zZSA9IGZ1bmNzID0+ICguLi5hcmdzKSA9PiB7XHJcbiAgY29uc3QgY3VyciA9IGZ1bmNzLnNoaWZ0KCk7XHJcbiAgcmV0dXJuIGN1cnIoLi4uYXJncywgKC4uLm5leHRBcmdzKSA9PiBjb21wb3NlKGZ1bmNzKSguLi5uZXh0QXJncykpO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuLyoqXHJcbiAqIEJlaGF2aW9yU3ViamVjdCBvZiB0aGUgZW50aXJlIHN0YXRlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZVN0cmVhbSBleHRlbmRzIEJlaGF2aW9yU3ViamVjdDxhbnk+IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKHt9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFNraXBTZWxmLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmd4c1BsdWdpbkZuLCBOR1hTX1BMVUdJTlMsIE5neHNQbHVnaW4gfSBmcm9tICcuL3N5bWJvbHMnO1xyXG5cclxuLyoqXHJcbiAqIFBsdWdpbiBtYW5hZ2VyIGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFBsdWdpbk1hbmFnZXIge1xyXG4gIHBsdWdpbnM6IE5neHNQbHVnaW5GbltdID0gW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBTa2lwU2VsZigpXHJcbiAgICBwcml2YXRlIF9wYXJlbnRNYW5hZ2VyOiBQbHVnaW5NYW5hZ2VyLFxyXG4gICAgQEluamVjdChOR1hTX1BMVUdJTlMpXHJcbiAgICBAT3B0aW9uYWwoKVxyXG4gICAgcHJpdmF0ZSBfcGx1Z2luczogTmd4c1BsdWdpbltdXHJcbiAgKSB7XHJcbiAgICB0aGlzLnJlZ2lzdGVyKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlZ2lzdGVyKCkge1xyXG4gICAgaWYgKCF0aGlzLl9wbHVnaW5zKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zLm1hcChwbHVnaW4gPT4ge1xyXG4gICAgICBpZiAocGx1Z2luLmhhbmRsZSkge1xyXG4gICAgICAgIHJldHVybiBwbHVnaW4uaGFuZGxlLmJpbmQocGx1Z2luKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcGx1Z2luO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fcGFyZW50TWFuYWdlcikge1xyXG4gICAgICB0aGlzLl9wYXJlbnRNYW5hZ2VyLnBsdWdpbnMucHVzaCguLi50aGlzLnBsdWdpbnMpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBFcnJvckhhbmRsZXIsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgZm9ya0pvaW4sIGVtcHR5LCBTdWJqZWN0LCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHNoYXJlUmVwbGF5LCBmaWx0ZXIsIGV4aGF1c3RNYXAsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBjb21wb3NlIH0gZnJvbSAnLi4vdXRpbHMvY29tcG9zZSc7XHJcbmltcG9ydCB7IEludGVybmFsQWN0aW9ucywgQWN0aW9uU3RhdHVzLCBBY3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBTdGF0ZVN0cmVhbSB9IGZyb20gJy4vc3RhdGUtc3RyZWFtJztcclxuaW1wb3J0IHsgUGx1Z2luTWFuYWdlciB9IGZyb20gJy4uL3BsdWdpbi1tYW5hZ2VyJztcclxuaW1wb3J0IHsgZW50ZXJab25lIH0gZnJvbSAnLi4vb3BlcmF0b3JzL3pvbmUnO1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIEFjdGlvbiByZXN1bHQgc3RyZWFtIHRoYXQgaXMgZW1pdHRlZCB3aGVuIGFuIGFjdGlvbiBpcyBjb21wbGV0ZWQuXHJcbiAqIFRoaXMgaXMgdXNlZCBhcyBhIG1ldGhvZCBvZiByZXR1cm5pbmcgdGhlIGFjdGlvbiByZXN1bHQgdG8gdGhlIGRpc3BhdGNoZXJcclxuICogZm9yIHRoZSBvYnNlcnZhYmxlIHJldHVybmVkIGJ5IHRoZSBkaXNwYXRjaCguLi4pIGNhbGwuXHJcbiAqIFRoZSBkaXNwYXRjaGVyIHRoZW4gYXN5bmNocm9ub3VzbHkgcHVzaGVzIHRoZSByZXN1bHQgZnJvbSB0aGlzIHN0cmVhbSBvbnRvIHRoZSBtYWluIGFjdGlvbiBzdHJlYW0gYXMgYSByZXN1bHQuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIGV4dGVuZHMgU3ViamVjdDxBY3Rpb25Db250ZXh0PiB7fVxyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxEaXNwYXRjaGVyIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX2Vycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uUmVzdWx0czogSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgIHByaXZhdGUgX3BsdWdpbk1hbmFnZXI6IFBsdWdpbk1hbmFnZXIsXHJcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogU3RhdGVTdHJlYW0sXHJcbiAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZVxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGF0Y2hlcyBldmVudChzKS5cclxuICAgKi9cclxuICBkaXNwYXRjaChldmVudDogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3QgcmVzdWx0OiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oZXZlbnQubWFwKGEgPT4gdGhpcy5kaXNwYXRjaFNpbmdsZShhKSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoU2luZ2xlKGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmVzdWx0LnN1YnNjcmliZSh7XHJcbiAgICAgIGVycm9yOiBlcnJvciA9PiB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuX2Vycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvcikpXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0LnBpcGUoZW50ZXJab25lKHRoaXMuX25nWm9uZSkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkaXNwYXRjaFNpbmdsZShhY3Rpb246IGFueSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpO1xyXG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbk1hbmFnZXIucGx1Z2lucztcclxuXHJcbiAgICByZXR1cm4gKGNvbXBvc2UoW1xyXG4gICAgICAuLi5wbHVnaW5zLFxyXG4gICAgICAobmV4dFN0YXRlLCBuZXh0QWN0aW9uKSA9PiB7XHJcbiAgICAgICAgaWYgKG5leHRTdGF0ZSAhPT0gcHJldlN0YXRlKSB7XHJcbiAgICAgICAgICB0aGlzLl9zdGF0ZVN0cmVhbS5uZXh0KG5leHRTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjdGlvblJlc3VsdCQgPSB0aGlzLmdldEFjdGlvblJlc3VsdFN0cmVhbShuZXh0QWN0aW9uKTtcclxuICAgICAgICBhY3Rpb25SZXN1bHQkLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9ucy5uZXh0KGN0eCkpO1xyXG4gICAgICAgIHRoaXMuX2FjdGlvbnMubmV4dCh7IGFjdGlvbjogbmV4dEFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEaXNwYXRjaE9ic2VydmFibGUoYWN0aW9uUmVzdWx0JCk7XHJcbiAgICAgIH1cclxuICAgIF0pKHByZXZTdGF0ZSwgYWN0aW9uKSBhcyBPYnNlcnZhYmxlPGFueT4pLnBpcGUoc2hhcmVSZXBsYXkoKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEFjdGlvblJlc3VsdFN0cmVhbShhY3Rpb246IGFueSk6IE9ic2VydmFibGU8QWN0aW9uQ29udGV4dD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGlvblJlc3VsdHMucGlwZShcclxuICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5hY3Rpb24gPT09IGFjdGlvbiAmJiBjdHguc3RhdHVzICE9PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXHJcbiAgICAgIHRha2UoMSksXHJcbiAgICAgIHNoYXJlUmVwbGF5KClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZURpc3BhdGNoT2JzZXJ2YWJsZShhY3Rpb25SZXN1bHQkOiBPYnNlcnZhYmxlPEFjdGlvbkNvbnRleHQ+KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiBhY3Rpb25SZXN1bHQkXHJcbiAgICAgIC5waXBlKFxyXG4gICAgICAgIGV4aGF1c3RNYXAoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4ge1xyXG4gICAgICAgICAgc3dpdGNoIChjdHguc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWw6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG9mKHRoaXMuX3N0YXRlU3RyZWFtLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICBjYXNlIEFjdGlvblN0YXR1cy5FcnJvcmVkOlxyXG4gICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGN0eC5lcnJvcik7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgKVxyXG4gICAgICAucGlwZShzaGFyZVJlcGxheSgpKTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIE9iamVjdCBmcmVlemUgY29kZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNkZi9kZWVwLWZyZWV6ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRlZXBGcmVlemUgPSBvID0+IHtcclxuICBPYmplY3QuZnJlZXplKG8pO1xyXG5cclxuICBjb25zdCBvSXNGdW5jdGlvbiA9IHR5cGVvZiBvID09PSAnZnVuY3Rpb24nO1xyXG4gIGNvbnN0IGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcclxuICAgIGlmIChcclxuICAgICAgaGFzT3duUHJvcC5jYWxsKG8sIHByb3ApICYmXHJcbiAgICAgIChvSXNGdW5jdGlvbiA/IHByb3AgIT09ICdjYWxsZXInICYmIHByb3AgIT09ICdjYWxsZWUnICYmIHByb3AgIT09ICdhcmd1bWVudHMnIDogdHJ1ZSkgJiZcclxuICAgICAgb1twcm9wXSAhPT0gbnVsbCAmJlxyXG4gICAgICAodHlwZW9mIG9bcHJvcF0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvW3Byb3BdID09PSAnZnVuY3Rpb24nKSAmJlxyXG4gICAgICAhT2JqZWN0LmlzRnJvemVuKG9bcHJvcF0pXHJcbiAgICApIHtcclxuICAgICAgZGVlcEZyZWV6ZShvW3Byb3BdKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG87XHJcbn07XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIGlzRGV2TW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVyIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IFN0YXRlU3RyZWFtIH0gZnJvbSAnLi9zdGF0ZS1zdHJlYW0nO1xyXG5pbXBvcnQgeyBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7IGRlZXBGcmVlemUgfSBmcm9tICcuLi91dGlscy9mcmVlemUnO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRlIENvbnRleHQgZmFjdG9yeSBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB7XHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc3RhdGVTdHJlYW06IFN0YXRlU3RyZWFtLCBwcml2YXRlIF9kaXNwYXRjaGVyOiBJbnRlcm5hbERpc3BhdGNoZXIsIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZykge1xyXG4gICAgdGhpcy52ZXJpZnlEZXZNb2RlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSByb290IHN0YXRlIG9wZXJhdG9ycy5cclxuICAgKi9cclxuICBnZXRSb290U3RhdGVPcGVyYXRpb25zKCk6IFN0YXRlT3BlcmF0aW9uczxhbnk+IHtcclxuICAgIGNvbnN0IHJvb3RTdGF0ZU9wZXJhdGlvbnMgPSB7XHJcbiAgICAgIGdldFN0YXRlOiAoKSA9PiB0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpLFxyXG4gICAgICBzZXRTdGF0ZTogbmV3U3RhdGUgPT4gdGhpcy5fc3RhdGVTdHJlYW0ubmV4dChuZXdTdGF0ZSksXHJcbiAgICAgIGRpc3BhdGNoOiBhY3Rpb25zID0+IHRoaXMuX2Rpc3BhdGNoZXIuZGlzcGF0Y2goYWN0aW9ucylcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5kZXZlbG9wbWVudE1vZGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlU3RhdGVBbmRBY3Rpb25zQXJlSW1tdXRhYmxlKHJvb3RTdGF0ZU9wZXJhdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb290U3RhdGVPcGVyYXRpb25zO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB2ZXJpZnlEZXZNb2RlKCkge1xyXG4gICAgY29uc3QgaXNOZ3hzRGV2TW9kZSA9IHRoaXMuX2NvbmZpZy5kZXZlbG9wbWVudE1vZGU7XHJcbiAgICBjb25zdCBpc05nRGV2TW9kZSA9IGlzRGV2TW9kZSgpO1xyXG4gICAgY29uc3QgaW5jb3JyZWN0UHJvZHVjdGlvbiA9ICFpc05nRGV2TW9kZSAmJiBpc05neHNEZXZNb2RlO1xyXG4gICAgY29uc3QgaW5jb3JyZWN0RGV2ZWxvcG1lbnQgPSBpc05nRGV2TW9kZSAmJiAhaXNOZ3hzRGV2TW9kZTtcclxuICAgIGNvbnN0IGV4YW1wbGUgPSAnTmd4c01vZHVsZS5mb3JSb290KHN0YXRlcywgeyBkZXZlbG9wbWVudE1vZGU6ICFlbnZpcm9ubWVudC5wcm9kdWN0aW9uIH0pJztcclxuXHJcbiAgICBpZiAoaW5jb3JyZWN0UHJvZHVjdGlvbikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgJ0FuZ3VsYXIgaXMgcnVubmluZyBpbiBwcm9kdWN0aW9uIG1vZGUgYnV0IE5HWFMgaXMgc3RpbGwgcnVubmluZyBpbiB0aGUgZGV2ZWxvcG1lbnQgbW9kZSFcXG4nLFxyXG4gICAgICAgICdQbGVhc2Ugc2V0IGRldmVsb3BtZW50TW9kZSB0byBmYWxzZSBvbiB0aGUgTmd4c01vZHVsZSBvcHRpb25zIHdoZW4gaW4gcHJvZHVjdGlvbiBtb2RlLlxcbicsXHJcbiAgICAgICAgZXhhbXBsZVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIGlmIChpbmNvcnJlY3REZXZlbG9wbWVudCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgJ1JFQ09NTUVOREFUSU9OOiBTZXQgZGV2ZWxvcG1lbnRNb2RlIHRvIHRydWUgb24gdGhlIE5neHNNb2R1bGUgd2hlbiBBbmd1bGFyIGlzIHJ1bm5pbmcgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG4nLFxyXG4gICAgICAgIGV4YW1wbGVcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZW5zdXJlU3RhdGVBbmRBY3Rpb25zQXJlSW1tdXRhYmxlKHJvb3Q6IFN0YXRlT3BlcmF0aW9uczxhbnk+KTogU3RhdGVPcGVyYXRpb25zPGFueT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2V0U3RhdGU6ICgpID0+IHJvb3QuZ2V0U3RhdGUoKSxcclxuICAgICAgc2V0U3RhdGU6IHZhbHVlID0+IHtcclxuICAgICAgICBjb25zdCBmcm96ZW5WYWx1ZSA9IGRlZXBGcmVlemUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByb290LnNldFN0YXRlKGZyb3plblZhbHVlKTtcclxuICAgICAgfSxcclxuICAgICAgZGlzcGF0Y2g6IGFjdGlvbnMgPT4ge1xyXG4gICAgICAgIHJldHVybiByb290LmRpc3BhdGNoKGFjdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dCB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQgeyBNYXBwZWRTdG9yZSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IHNldFZhbHVlLCBnZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1vcGVyYXRpb25zJztcclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBDb250ZXh0IGZhY3RvcnkgY2xhc3NcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RhdGVDb250ZXh0RmFjdG9yeSB7XHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIHN0YXRlIGNvbnRleHRcclxuICAgKi9cclxuICBjcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGE6IE1hcHBlZFN0b3JlKTogU3RhdGVDb250ZXh0PGFueT4ge1xyXG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldFN0YXRlKCk6IGFueSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSByb290LmdldFN0YXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlKHN0YXRlLCBtZXRhZGF0YS5kZXB0aCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHBhdGNoU3RhdGUodmFsOiBhbnkpOiBhbnkge1xyXG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbCk7XHJcbiAgICAgICAgY29uc3QgaXNQcmltaXRpdmUgPSB0eXBlb2YgdmFsICE9PSAnb2JqZWN0JztcclxuXHJcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0Y2hpbmcgYXJyYXlzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRjaGluZyBwcmltaXRpdmVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHJvb3QuZ2V0U3RhdGUoKTtcclxuICAgICAgICBjb25zdCBsb2NhbCA9IGdldFZhbHVlKHN0YXRlLCBtZXRhZGF0YS5kZXB0aCk7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSB7IC4uLmxvY2FsIH07XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgayBpbiB2YWwpIHtcclxuICAgICAgICAgIGNsb25lW2tdID0gdmFsW2tdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBzZXRWYWx1ZShzdGF0ZSwgbWV0YWRhdGEuZGVwdGgsIGNsb25lKTtcclxuICAgICAgICByb290LnNldFN0YXRlKG5ld1N0YXRlKTtcclxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldFN0YXRlKHZhbDogYW55KTogYW55IHtcclxuICAgICAgICBsZXQgc3RhdGUgPSByb290LmdldFN0YXRlKCk7XHJcbiAgICAgICAgc3RhdGUgPSBzZXRWYWx1ZShzdGF0ZSwgbWV0YWRhdGEuZGVwdGgsIHZhbCk7XHJcbiAgICAgICAgcm9vdC5zZXRTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICB9LFxyXG4gICAgICBkaXNwYXRjaChhY3Rpb25zOiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIHJvb3QuZGlzcGF0Y2goYWN0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdG9yLCBJbmplY3RhYmxlLCBTa2lwU2VsZiwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIGZvcmtKb2luLCBmcm9tLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHNoYXJlUmVwbGF5LCB0YWtlVW50aWwsIG1hcCwgY2F0Y2hFcnJvciwgZmlsdGVyLCBtZXJnZU1hcCwgZGVmYXVsdElmRW1wdHkgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBNRVRBX0tFWSwgTmd4c0xpZmVDeWNsZSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQge1xyXG4gIHRvcG9sb2dpY2FsU29ydCxcclxuICBidWlsZEdyYXBoLFxyXG4gIGZpbmRGdWxsUGFyZW50UGF0aCxcclxuICBuYW1lVG9TdGF0ZSxcclxuICBwcm9wR2V0dGVyLFxyXG4gIGlzT2JqZWN0LFxyXG4gIFN0YXRlQ2xhc3MsXHJcbiAgTWFwcGVkU3RvcmVcclxufSBmcm9tICcuL2ludGVybmFscyc7XHJcbmltcG9ydCB7IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UsIHNldFZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBvZkFjdGlvbkRpc3BhdGNoZWQgfSBmcm9tICcuLi9vcGVyYXRvcnMvb2YtYWN0aW9uJztcclxuaW1wb3J0IHsgSW50ZXJuYWxBY3Rpb25zLCBBY3Rpb25TdGF0dXMsIEFjdGlvbkNvbnRleHQgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XHJcbmltcG9ydCB7IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMgfSBmcm9tICcuLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgU3RhdGVDb250ZXh0RmFjdG9yeSB9IGZyb20gJy4uL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XHJcblxyXG4vKipcclxuICogU3RhdGUgZmFjdG9yeSBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZUZhY3Rvcnkge1xyXG4gIGdldCBzdGF0ZXMoKTogTWFwcGVkU3RvcmVbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzIDogdGhpcy5fc3RhdGVzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc3RhdGVzOiBNYXBwZWRTdG9yZVtdID0gW107XHJcbiAgcHJpdmF0ZSBfY29ubmVjdGVkID0gZmFsc2U7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxyXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBOZ3hzQ29uZmlnLFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBTa2lwU2VsZigpXHJcbiAgICBwcml2YXRlIF9wYXJlbnRGYWN0b3J5OiBTdGF0ZUZhY3RvcnksXHJcbiAgICBwcml2YXRlIF9hY3Rpb25zOiBJbnRlcm5hbEFjdGlvbnMsXHJcbiAgICBwcml2YXRlIF9hY3Rpb25SZXN1bHRzOiBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzLFxyXG4gICAgcHJpdmF0ZSBfc3RhdGVDb250ZXh0RmFjdG9yeTogU3RhdGVDb250ZXh0RmFjdG9yeVxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgbmV3IHN0YXRlIHRvIHRoZSBnbG9iYWwgZGVmcy5cclxuICAgKi9cclxuICBhZGQob25lT3JNYW55U3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzIHwgU3RhdGVDbGFzc1tdKTogTWFwcGVkU3RvcmVbXSB7XHJcbiAgICBsZXQgc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW107XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob25lT3JNYW55U3RhdGVDbGFzc2VzKSkge1xyXG4gICAgICBzdGF0ZUNsYXNzZXMgPSBbb25lT3JNYW55U3RhdGVDbGFzc2VzXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXRlQ2xhc3NlcyA9IG9uZU9yTWFueVN0YXRlQ2xhc3NlcztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdGF0ZUdyYXBoID0gYnVpbGRHcmFwaChzdGF0ZUNsYXNzZXMpO1xyXG4gICAgY29uc3Qgc29ydGVkU3RhdGVzID0gdG9wb2xvZ2ljYWxTb3J0KHN0YXRlR3JhcGgpO1xyXG4gICAgY29uc3QgZGVwdGhzID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xyXG4gICAgY29uc3QgbmFtZUdyYXBoID0gbmFtZVRvU3RhdGUoc3RhdGVDbGFzc2VzKTtcclxuICAgIGNvbnN0IG1hcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3J0ZWRTdGF0ZXMpIHtcclxuICAgICAgY29uc3Qgc3RhdGVDbGFzcyA9IG5hbWVHcmFwaFtuYW1lXTtcclxuXHJcbiAgICAgIGlmICghc3RhdGVDbGFzc1tNRVRBX0tFWV0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlcyBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvcicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkZXB0aCA9IGRlcHRoc1tuYW1lXTtcclxuICAgICAgY29uc3QgeyBhY3Rpb25zIH0gPSBzdGF0ZUNsYXNzW01FVEFfS0VZXTtcclxuICAgICAgbGV0IHsgZGVmYXVsdHMgfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldO1xyXG5cclxuICAgICAgc3RhdGVDbGFzc1tNRVRBX0tFWV0ucGF0aCA9IGRlcHRoO1xyXG4gICAgICBzdGF0ZUNsYXNzW01FVEFfS0VZXS5zZWxlY3RGcm9tQXBwU3RhdGUgPSBwcm9wR2V0dGVyKGRlcHRoLnNwbGl0KCcuJyksIHRoaXMuX2NvbmZpZyk7XHJcblxyXG4gICAgICAvLyBlbnN1cmUgb3VyIHN0b3JlIGhhc24ndCBhbHJlYWR5IGJlZW4gYWRkZWRcclxuICAgICAgLy8gYnV0IGRvbnQgdGhyb3cgc2luY2UgaXQgY291bGQgYmUgbGF6eVxyXG4gICAgICAvLyBsb2FkZWQgZnJvbSBkaWZmZXJlbnQgcGF0aHNcclxuICAgICAgY29uc3QgaGFzID0gdGhpcy5zdGF0ZXMuZmluZChzID0+IHMubmFtZSA9PT0gbmFtZSk7XHJcbiAgICAgIGlmICghaGFzKSB7XHJcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBpbnN0YW5jZSBvZiBkZWZhdWx0c1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRzKSkge1xyXG4gICAgICAgICAgZGVmYXVsdHMgPSBbLi4uZGVmYXVsdHNdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGVmYXVsdHMpKSB7XHJcbiAgICAgICAgICBkZWZhdWx0cyA9IHsgLi4uZGVmYXVsdHMgfTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGRlZmF1bHRzID0ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX2luamVjdG9yLmdldChzdGF0ZUNsYXNzKTtcclxuXHJcbiAgICAgICAgbWFwcGVkU3RvcmVzLnB1c2goe1xyXG4gICAgICAgICAgYWN0aW9ucyxcclxuICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgZGVmYXVsdHMsXHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgZGVwdGhcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhdGVzLnB1c2goLi4ubWFwcGVkU3RvcmVzKTtcclxuXHJcbiAgICByZXR1cm4gbWFwcGVkU3RvcmVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc2V0IG9mIHN0YXRlcyB0byB0aGUgc3RvcmUgYW5kIHJldHVybiB0aGUgZGVmYXVsc3RzXHJcbiAgICovXHJcbiAgYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVDbGFzc2VzOiBhbnlbXSk6IHsgZGVmYXVsdHM6IGFueTsgc3RhdGVzOiBNYXBwZWRTdG9yZVtdIH0ge1xyXG4gICAgaWYgKHN0YXRlQ2xhc3Nlcykge1xyXG4gICAgICBjb25zdCBzdGF0ZXMgPSB0aGlzLmFkZChzdGF0ZUNsYXNzZXMpO1xyXG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN0YXRlcy5yZWR1Y2UoXHJcbiAgICAgICAgKHJlc3VsdDogYW55LCBtZXRhOiBNYXBwZWRTdG9yZSkgPT4gc2V0VmFsdWUocmVzdWx0LCBtZXRhLmRlcHRoLCBtZXRhLmRlZmF1bHRzKSxcclxuICAgICAgICB7fVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIHRoZSBhY3Rpb25zIHRvIHRoZSBoYW5kbGVyc1xyXG4gICAqL1xyXG4gIGNvbm5lY3RBY3Rpb25IYW5kbGVycygpIHtcclxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHJldHVybjtcclxuICAgIHRoaXMuX2FjdGlvbnNcclxuICAgICAgLnBpcGUoXHJcbiAgICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5zdGF0dXMgPT09IEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKSxcclxuICAgICAgICBtZXJnZU1hcCgoeyBhY3Rpb24gfSkgPT5cclxuICAgICAgICAgIHRoaXMuaW52b2tlQWN0aW9ucyh0aGlzLl9hY3Rpb25zLCBhY3Rpb24pLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoKSA9PiA8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCB9KSxcclxuICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkNhbmNlbGVkIH0pLFxyXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVycm9yID0+IG9mKDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5FcnJvcmVkLCBlcnJvciB9KSlcclxuICAgICAgICAgIClcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgICAgLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9uUmVzdWx0cy5uZXh0KGN0eCkpO1xyXG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZSB0aGUgaW5pdCBmdW5jdGlvbiBvbiB0aGUgc3RhdGVzLlxyXG4gICAqL1xyXG4gIGludm9rZUluaXQoc3RhdGVNZXRhZGF0YXM6IE1hcHBlZFN0b3JlW10pIHtcclxuICAgIGZvciAoY29uc3QgbWV0YWRhdGEgb2Ygc3RhdGVNZXRhZGF0YXMpIHtcclxuICAgICAgY29uc3QgaW5zdGFuY2U6IE5neHNMaWZlQ3ljbGUgPSBtZXRhZGF0YS5pbnN0YW5jZTtcclxuXHJcbiAgICAgIGlmIChpbnN0YW5jZS5uZ3hzT25Jbml0KSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gICAgICAgIGluc3RhbmNlLm5neHNPbkluaXQoc3RhdGVDb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlIGFjdGlvbnMgb24gdGhlIHN0YXRlcy5cclxuICAgKi9cclxuICBpbnZva2VBY3Rpb25zKGFjdGlvbnMkOiBJbnRlcm5hbEFjdGlvbnMsIGFjdGlvbikge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgbWV0YWRhdGEgb2YgdGhpcy5zdGF0ZXMpIHtcclxuICAgICAgY29uc3QgdHlwZSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uKTtcclxuICAgICAgY29uc3QgYWN0aW9uTWV0YXMgPSBtZXRhZGF0YS5hY3Rpb25zW3R5cGVdO1xyXG5cclxuICAgICAgaWYgKGFjdGlvbk1ldGFzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25NZXRhIG9mIGFjdGlvbk1ldGFzKSB7XHJcbiAgICAgICAgICBjb25zdCBzdGF0ZUNvbnRleHQgPSB0aGlzLmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGEuaW5zdGFuY2VbYWN0aW9uTWV0YS5mbl0oc3RhdGVDb250ZXh0LCBhY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBmcm9tKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUoXHJcbiAgICAgICAgICAgICAgICBhY3Rpb25NZXRhLm9wdGlvbnMuY2FuY2VsVW5jb21wbGV0ZWRcclxuICAgICAgICAgICAgICAgICAgPyB0YWtlVW50aWwoYWN0aW9ucyQucGlwZShvZkFjdGlvbkRpc3BhdGNoZWQoYWN0aW9uKSkpXHJcbiAgICAgICAgICAgICAgICAgIDogbWFwKHIgPT4gcilcclxuICAgICAgICAgICAgICApOyAvLyBtYXAgYWN0cyBsaWtlIGEgbm9vcFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IG9mKHt9KS5waXBlKHNoYXJlUmVwbGF5KCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRocm93RXJyb3IoZSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgcmVzdWx0cy5wdXNoKG9mKHt9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvcmtKb2luKHJlc3VsdHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBzdGF0ZSBjb250ZXh0XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGE6IE1hcHBlZFN0b3JlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVDb250ZXh0RmFjdG9yeS5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gIH1cclxufVxyXG4iLCJmdW5jdGlvbiBkZWZhdWx0RXF1YWxpdHlDaGVjayhhLCBiKSB7XHJcbiAgcmV0dXJuIGEgPT09IGI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKGVxdWFsaXR5Q2hlY2ssIHByZXYsIG5leHQpIHtcclxuICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cclxuICBjb25zdCBsZW5ndGggPSBwcmV2Lmxlbmd0aDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZW1vaXplIGEgZnVuY3Rpb24gb24gaXRzIGxhc3QgaW5wdXRzIG9ubHkuXHJcbiAqIE9yaW5naW5hbGx5IGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3Jlc2VsZWN0L2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCBlcXVhbGl0eUNoZWNrID0gZGVmYXVsdEVxdWFsaXR5Q2hlY2spIHtcclxuICBsZXQgbGFzdEFyZ3MgPSBudWxsO1xyXG4gIGxldCBsYXN0UmVzdWx0ID0gbnVsbDtcclxuICAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcclxuICByZXR1cm4gPCguLi5hcmdzKSA9PiBhbnk+ZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XHJcbiAgICBpZiAoIWFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKGVxdWFsaXR5Q2hlY2ssIGxhc3RBcmdzLCBhcmd1bWVudHMpKSB7XHJcbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXHJcbiAgICAgIGxhc3RSZXN1bHQgPSBmdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IFNlbGVjdEZyb21TdGF0ZSwgZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSwgZ2V0U2VsZWN0b3JNZXRhZGF0YSwgZ2V0U3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuLi91dGlscy9tZW1vaXplJztcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBzZWxlY3RvclxyXG4gKiBAcGFyYW0gc2VsZWN0b3JzIFRoZSBzZWxlY3RvcnMgdG8gdXNlIHRvIGNyZWF0ZSB0aGUgYXJndW1lbnRzIG9mIHRoaXMgZnVuY3Rpb25cclxuICogQHBhcmFtIG9yaWdpbmFsRm4gVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGJlaW5nIG1hZGUgaW50byBhIHNlbGVjdG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoXHJcbiAgc2VsZWN0b3JzOiBhbnlbXSxcclxuICBvcmlnaW5hbEZuOiBhbnksXHJcbiAgY3JlYXRpb25NZXRhZGF0YT86IHsgY29udGFpbmVyQ2xhc3M6IGFueTsgc2VsZWN0b3JOYW1lOiBzdHJpbmcgfVxyXG4pIHtcclxuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiB3cmFwcGVkU2VsZWN0b3JGbiguLi5hcmdzKSB7XHJcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9yaWdpbmFsRm4oLi4uYXJncyk7XHJcbiAgICBpZiAocmV0dXJuVmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICBjb25zdCBpbm5lck1lbW9pemVkRm4gPSBtZW1vaXplLmFwcGx5KG51bGwsIFtyZXR1cm5WYWx1ZV0pO1xyXG4gICAgICByZXR1cm4gaW5uZXJNZW1vaXplZEZuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gIH07XHJcbiAgY29uc3QgbWVtb2l6ZWRGbiA9IG1lbW9pemUod3JhcHBlZEZuKTtcclxuICBjb25zdCBjb250YWluZXJDbGFzcyA9IGNyZWF0aW9uTWV0YWRhdGEgJiYgY3JlYXRpb25NZXRhZGF0YS5jb250YWluZXJDbGFzcztcclxuXHJcbiAgY29uc3QgZm4gPSBzdGF0ZSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgY29uc3Qgc2VsZWN0b3JzVG9BcHBseSA9IFtdO1xyXG5cclxuICAgIGlmIChjb250YWluZXJDbGFzcykge1xyXG4gICAgICAvLyBJZiB3ZSBhcmUgb24gYSBzdGF0ZSBjbGFzcywgYWRkIGl0IGFzIHRoZSBmaXJzdCBzZWxlY3RvciBwYXJhbWV0ZXJcclxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBnZXRTdG9yZU1ldGFkYXRhKGNvbnRhaW5lckNsYXNzKTtcclxuICAgICAgaWYgKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKGNvbnRhaW5lckNsYXNzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNlbGVjdG9ycykge1xyXG4gICAgICBzZWxlY3RvcnNUb0FwcGx5LnB1c2goLi4uc2VsZWN0b3JzKTtcclxuICAgIH1cclxuICAgIC8vIERldGVybWluZSBhcmd1bWVudHMgZnJvbSB0aGUgYXBwIHN0YXRlIHVzaW5nIHRoZSBzZWxlY3RvcnNcclxuICAgIGlmIChzZWxlY3RvcnNUb0FwcGx5KSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaCguLi5zZWxlY3RvcnNUb0FwcGx5Lm1hcChhID0+IGdldFNlbGVjdG9yRm4oYSkoc3RhdGUpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdGhlIGxhbWJkYSB0cmllcyB0byBhY2Nlc3MgYSBzb21ldGhpbmcgb24gdGhlXHJcbiAgICAvLyBzdGF0ZSB0aGF0IGRvZXNuJ3QgZXhpc3QsIGl0IHdpbGwgdGhyb3cgYSBUeXBlRXJyb3IuXHJcbiAgICAvLyBzaW5jZSB0aGlzIGlzIHF1aXRlIHVzdWFsIGJlaGF2aW91ciwgd2Ugc2ltcGx5IHJldHVybiB1bmRlZmluZWQgaWYgc28uXHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gbWVtb2l6ZWRGbiguLi5yZXN1bHRzKTtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXg7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgc2VsZWN0b3JNZXRhRGF0YSA9IGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEobWVtb2l6ZWRGbik7XHJcbiAgc2VsZWN0b3JNZXRhRGF0YS5vcmlnaW5hbEZuID0gb3JpZ2luYWxGbjtcclxuICBzZWxlY3Rvck1ldGFEYXRhLnNlbGVjdEZyb21BcHBTdGF0ZSA9IGZuO1xyXG4gIGlmIChjcmVhdGlvbk1ldGFkYXRhKSB7XHJcbiAgICBzZWxlY3Rvck1ldGFEYXRhLmNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YS5jb250YWluZXJDbGFzcztcclxuICAgIHNlbGVjdG9yTWV0YURhdGEuc2VsZWN0b3JOYW1lID0gY3JlYXRpb25NZXRhZGF0YS5zZWxlY3Rvck5hbWU7XHJcbiAgfVxyXG4gIHJldHVybiBtZW1vaXplZEZuO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB0byBiZSB1c2VkIHRvIGdldCB0aGUgc2VsZWN0ZWQgc2xpY2UgZnJvbSB0aGUgYXBwIHN0YXRlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvckZuKHNlbGVjdG9yOiBhbnkpOiBTZWxlY3RGcm9tU3RhdGUge1xyXG4gIGNvbnN0IG1ldGFkYXRhID0gZ2V0U2VsZWN0b3JNZXRhZGF0YShzZWxlY3RvcikgfHwgZ2V0U3RvcmVNZXRhZGF0YShzZWxlY3Rvcik7XHJcbiAgcmV0dXJuIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5zZWxlY3RGcm9tQXBwU3RhdGUpIHx8IHNlbGVjdG9yO1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGNhdGNoRXJyb3IsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBnZXRTZWxlY3RvckZuIH0gZnJvbSAnLi91dGlscy9zZWxlY3Rvci11dGlscyc7XHJcbmltcG9ydCB7IEludGVybmFsU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1vcGVyYXRpb25zJztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IGVudGVyWm9uZSB9IGZyb20gJy4vb3BlcmF0b3JzL3pvbmUnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RvcmUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXHJcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogU3RhdGVTdHJlYW0sXHJcbiAgICBwcml2YXRlIF9pbnRlcm5hbFN0YXRlT3BlcmF0aW9uczogSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnNcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgZXZlbnQocykuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goZXZlbnQ6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuZGlzcGF0Y2goZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0cyBhIHNsaWNlIG9mIGRhdGEgZnJvbSB0aGUgc3RvcmUuXHJcbiAgICovXHJcbiAgc2VsZWN0PFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IE9ic2VydmFibGU8VD47XHJcbiAgc2VsZWN0KHNlbGVjdG9yOiBzdHJpbmcgfCBhbnkpOiBPYnNlcnZhYmxlPGFueT47XHJcbiAgc2VsZWN0KHNlbGVjdG9yOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3Qgc2VsZWN0b3JGbiA9IGdldFNlbGVjdG9yRm4oc2VsZWN0b3IpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlU3RyZWFtLnBpcGUoXHJcbiAgICAgIG1hcChzZWxlY3RvckZuKSxcclxuICAgICAgY2F0Y2hFcnJvcihlcnIgPT4ge1xyXG4gICAgICAgIC8vIGlmIGVycm9yIGlzIFR5cGVFcnJvciB3ZSBzd2FsbG93IGl0IHRvIHByZXZlbnQgdXN1YWwgZXJyb3JzIHdpdGggcHJvcGVydHkgYWNjZXNzXHJcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXRocm93IG90aGVyIGVycm9yc1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgICAgfSksXHJcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICAgIGVudGVyWm9uZSh0aGlzLl9uZ1pvbmUpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0IG9uZSBzbGljZSBvZiBkYXRhIGZyb20gdGhlIHN0b3JlLlxyXG4gICAqL1xyXG4gIHNlbGVjdE9uY2U8VD4oc2VsZWN0b3I6IChzdGF0ZTogYW55LCAuLi5zdGF0ZXM6IGFueVtdKSA9PiBUKTogT2JzZXJ2YWJsZTxUPjtcclxuICBzZWxlY3RPbmNlKHNlbGVjdG9yOiBzdHJpbmcgfCBhbnkpOiBPYnNlcnZhYmxlPGFueT47XHJcbiAgc2VsZWN0T25jZShzZWxlY3RvcjogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiB0aGlzLnNlbGVjdChzZWxlY3RvcikucGlwZSh0YWtlKDEpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdCBhIHNuYXBzaG90IGZyb20gdGhlIHN0YXRlLlxyXG4gICAqL1xyXG4gIHNlbGVjdFNuYXBzaG90PFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IFQ7XHJcbiAgc2VsZWN0U25hcHNob3Qoc2VsZWN0b3I6IHN0cmluZyB8IGFueSk6IGFueTtcclxuICBzZWxlY3RTbmFwc2hvdChzZWxlY3RvcjogYW55KTogYW55IHtcclxuICAgIGNvbnN0IHNlbGVjdG9yRm4gPSBnZXRTZWxlY3RvckZuKHNlbGVjdG9yKTtcclxuICAgIHJldHVybiBzZWxlY3RvckZuKHRoaXMuX3N0YXRlU3RyZWFtLmdldFZhbHVlKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gc3Vic2NyaWJlIHRvIHRoZSByb290IG9mIHRoZSBzdGF0ZVxyXG4gICAqL1xyXG4gIHN1YnNjcmliZShmbj86IGFueSk6IFN1YnNjcmlwdGlvbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVTdHJlYW0ucGlwZShlbnRlclpvbmUodGhpcy5fbmdab25lKSkuc3Vic2NyaWJlKGZuKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgcmF3IHZhbHVlIG9mIHRoZSBzdGF0ZS5cclxuICAgKi9cclxuICBzbmFwc2hvdCgpOiBhbnkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKS5nZXRTdGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZS4gVGhpcyBtZXRob2QgaXMgdXNlZnVsXHJcbiAgICogZm9yIHBsdWdpbidzIHdobyBuZWVkIHRvIG1vZGlmeSB0aGUgc3RhdGUgZGlyZWN0bHkgb3IgdW5pdCB0ZXN0aW5nLlxyXG4gICAqL1xyXG4gIHJlc2V0KHN0YXRlOiBhbnkpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuc2V0U3RhdGUoc3RhdGUpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJy4uL3N0b3JlJztcclxuaW1wb3J0IHsgcHJvcEdldHRlciB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IE1FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcblxyXG4vKipcclxuICogQWxsb3dzIHRoZSBzZWxlY3QgZGVjb3JhdG9yIHRvIGdldCBhY2Nlc3MgdG8gdGhlIERJIHN0b3JlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3RGYWN0b3J5IHtcclxuICBzdGF0aWMgc3RvcmU6IFN0b3JlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gIHN0YXRpYyBjb25maWc6IE5neHNDb25maWcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgY29uc3RydWN0b3Ioc3RvcmU6IFN0b3JlLCBjb25maWc6IE5neHNDb25maWcpIHtcclxuICAgIFNlbGVjdEZhY3Rvcnkuc3RvcmUgPSBzdG9yZTtcclxuICAgIFNlbGVjdEZhY3RvcnkuY29uZmlnID0gY29uZmlnO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29yYXRvciBmb3Igc2VsZWN0aW5nIGEgc2xpY2Ugb2Ygc3RhdGUgZnJvbSB0aGUgc3RvcmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0KHNlbGVjdG9yT3JGZWF0dXJlPywgLi4ucGF0aHM6IHN0cmluZ1tdKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55LCBuYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHNlbGVjdG9yRm5OYW1lID0gJ19fJyArIG5hbWUgKyAnX19zZWxlY3Rvcic7XHJcblxyXG4gICAgaWYgKCFzZWxlY3Rvck9yRmVhdHVyZSkge1xyXG4gICAgICAvLyBpZiBmb28kID0+IG1ha2UgaXQganVzdCBmb29cclxuICAgICAgc2VsZWN0b3JPckZlYXR1cmUgPSBuYW1lLmxhc3RJbmRleE9mKCckJykgPT09IG5hbWUubGVuZ3RoIC0gMSA/IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSkgOiBuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNyZWF0ZVNlbGVjdCA9IGZuID0+IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSBTZWxlY3RGYWN0b3J5LnN0b3JlO1xyXG5cclxuICAgICAgaWYgKCFzdG9yZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VsZWN0RmFjdG9yeSBub3QgY29ubmVjdGVkIHRvIHN0b3JlIScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RvcmUuc2VsZWN0KGZuKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY3JlYXRlU2VsZWN0b3IgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IFNlbGVjdEZhY3RvcnkuY29uZmlnO1xyXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yT3JGZWF0dXJlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IHByb3BzQXJyYXkgPSBwYXRocy5sZW5ndGggPyBbc2VsZWN0b3JPckZlYXR1cmUsIC4uLnBhdGhzXSA6IHNlbGVjdG9yT3JGZWF0dXJlLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9wR2V0dGVyKHByb3BzQXJyYXksIGNvbmZpZyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3JPckZlYXR1cmVbTUVUQV9LRVldICYmIHNlbGVjdG9yT3JGZWF0dXJlW01FVEFfS0VZXS5wYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BHZXR0ZXIoc2VsZWN0b3JPckZlYXR1cmVbTUVUQV9LRVldLnBhdGguc3BsaXQoJy4nKSwgY29uZmlnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc2VsZWN0b3JPckZlYXR1cmU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHRhcmdldFtzZWxlY3RvckZuTmFtZV0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBAU2VsZWN0IGRlY29yYXRvciBhbmQgYSAnICsgc2VsZWN0b3JGbk5hbWUgKyAnIHByb3BlcnR5LicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkZWxldGUgdGFyZ2V0W25hbWVdKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHNlbGVjdG9yRm5OYW1lLCB7XHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpc1tzZWxlY3RvckZuTmFtZV0gfHwgKHRoaXNbc2VsZWN0b3JGbk5hbWVdID0gY3JlYXRlU2VsZWN0LmFwcGx5KHRoaXMsIFtjcmVhdGVTZWxlY3RvcigpXSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4iLCIvKipcclxuICogSW5pdCBhY3Rpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbml0U3RhdGUge1xyXG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuICAgIC8vIE5PVEU6IE5vdCBuZWNlc3NhcnkgdG8gZGVjbGFyZSB0aGUgdHlwZSBpbiB0aGlzIHdheSBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmd4cy9zdG9yZS9wdWxsLzY0NCNpc3N1ZWNvbW1lbnQtNDM2MDAzMTM4XHJcbiAgICByZXR1cm4gJ0BASU5JVCc7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIGFjdGlvblxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFVwZGF0ZVN0YXRlIHtcclxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcbiAgICAvLyBOT1RFOiBOb3QgbmVjZXNzYXJ5IHRvIGRlY2xhcmUgdGhlIHR5cGUgaW4gdGhpcyB3YXkgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25neHMvc3RvcmUvcHVsbC82NDQjaXNzdWVjb21tZW50LTQzNjAwMzEzOFxyXG4gICAgcmV0dXJuICdAQFVQREFURV9TVEFURSc7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IE5nTW9kdWxlLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBPcHRpb25hbCwgSW5qZWN0LCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgUk9PVF9TVEFURV9UT0tFTiwgRkVBVFVSRV9TVEFURV9UT0tFTiwgTmd4c0NvbmZpZyB9IGZyb20gJy4vc3ltYm9scyc7XHJcbmltcG9ydCB7IFN0YXRlRmFjdG9yeSB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtZmFjdG9yeSc7XHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XHJcbmltcG9ydCB7IEFjdGlvbnMsIEludGVybmFsQWN0aW9ucyB9IGZyb20gJy4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZXIsIEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMgfSBmcm9tICcuL2ludGVybmFsL2Rpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnLi9zdG9yZSc7XHJcbmltcG9ydCB7IFNlbGVjdEZhY3RvcnkgfSBmcm9tICcuL2RlY29yYXRvcnMvc2VsZWN0JztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IFBsdWdpbk1hbmFnZXIgfSBmcm9tICcuL3BsdWdpbi1tYW5hZ2VyJztcclxuaW1wb3J0IHsgSW5pdFN0YXRlLCBVcGRhdGVTdGF0ZSB9IGZyb20gJy4vYWN0aW9ucy9hY3Rpb25zJztcclxuXHJcbi8qKlxyXG4gKiBSb290IG1vZHVsZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ATmdNb2R1bGUoKVxyXG5leHBvcnQgY2xhc3MgTmd4c1Jvb3RNb2R1bGUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgZmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxyXG4gICAgc3RvcmU6IFN0b3JlLFxyXG4gICAgc2VsZWN0OiBTZWxlY3RGYWN0b3J5LFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoUk9PVF9TVEFURV9UT0tFTilcclxuICAgIHN0YXRlczogYW55W11cclxuICApIHtcclxuICAgIC8vIGFkZCBzdG9yZXMgdG8gdGhlIHN0YXRlIGdyYXBoIGFuZCByZXR1cm4gdGhlaXIgZGVmYXVsdHNcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBmYWN0b3J5LmFkZEFuZFJldHVybkRlZmF1bHRzKHN0YXRlcyk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGVPcGVyYXRpb25zID0gaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpO1xyXG4gICAgaWYgKHJlc3VsdHMpIHtcclxuICAgICAgLy8gZ2V0IG91ciBjdXJyZW50IHN0cmVhbVxyXG4gICAgICBjb25zdCBjdXIgPSBzdGF0ZU9wZXJhdGlvbnMuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIC8vIHNldCB0aGUgc3RhdGUgdG8gdGhlIGN1cnJlbnQgKyBuZXdcclxuICAgICAgc3RhdGVPcGVyYXRpb25zLnNldFN0YXRlKHsgLi4uY3VyLCAuLi5yZXN1bHRzLmRlZmF1bHRzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbm5lY3Qgb3VyIGFjdGlvbnMgc3RyZWFtXHJcbiAgICBmYWN0b3J5LmNvbm5lY3RBY3Rpb25IYW5kbGVycygpO1xyXG5cclxuICAgIC8vIGRpc3BhdGNoIHRoZSBpbml0IGFjdGlvbiBhbmQgaW52b2tlIGluaXQgZnVuY3Rpb24gYWZ0ZXJcclxuICAgIHN0YXRlT3BlcmF0aW9ucy5kaXNwYXRjaChuZXcgSW5pdFN0YXRlKCkpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgIGlmIChyZXN1bHRzKSB7XHJcbiAgICAgICAgZmFjdG9yeS5pbnZva2VJbml0KHJlc3VsdHMuc3RhdGVzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmVhdHVyZSBtb2R1bGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQE5nTW9kdWxlKHt9KVxyXG5leHBvcnQgY2xhc3MgTmd4c0ZlYXR1cmVNb2R1bGUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgc3RvcmU6IFN0b3JlLFxyXG4gICAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxyXG4gICAgZmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoRkVBVFVSRV9TVEFURV9UT0tFTilcclxuICAgIHN0YXRlczogYW55W11bXVxyXG4gICkge1xyXG4gICAgLy8gU2luY2UgRkVBVFVSRV9TVEFURV9UT0tFTiBpcyBhIG11bHRpIHRva2VuLCB3ZSBuZWVkIHRvXHJcbiAgICAvLyBmbGF0dGVuIGl0IFtbRmVhdHVyZTFTdGF0ZSwgRmVhdHVyZTJTdGF0ZV0sIFtGZWF0dXJlM1N0YXRlXV1cclxuICAgIGNvbnN0IGZsYXR0ZW5lZFN0YXRlcyA9IChbXSBhcyBhbnlbXSkuY29uY2F0KC4uLnN0YXRlcyk7XHJcblxyXG4gICAgLy8gYWRkIHN0b3JlcyB0byB0aGUgc3RhdGUgZ3JhcGggYW5kIHJldHVybiB0aGVpciBkZWZhdWx0c1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGZhY3RvcnkuYWRkQW5kUmV0dXJuRGVmYXVsdHMoZmxhdHRlbmVkU3RhdGVzKTtcclxuXHJcbiAgICBjb25zdCBzdGF0ZU9wZXJhdGlvbnMgPSBpbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCk7XHJcbiAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAvLyBnZXQgb3VyIGN1cnJlbnQgc3RyZWFtXHJcbiAgICAgIGNvbnN0IGN1ciA9IHN0YXRlT3BlcmF0aW9ucy5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgLy8gc2V0IHRoZSBzdGF0ZSB0byB0aGUgY3VycmVudCArIG5ld1xyXG4gICAgICBzdGF0ZU9wZXJhdGlvbnMuc2V0U3RhdGUoeyAuLi5jdXIsIC4uLnJlc3VsdHMuZGVmYXVsdHMgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGVPcGVyYXRpb25zLmRpc3BhdGNoKG5ldyBVcGRhdGVTdGF0ZSgpKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAgIGZhY3RvcnkuaW52b2tlSW5pdChyZXN1bHRzLnN0YXRlcyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTW9kdWxlT3B0aW9ucyA9IFBhcnRpYWw8Tmd4c0NvbmZpZz47XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbmd4c0NvbmZpZ0ZhY3Rvcnkob3B0aW9uczogTW9kdWxlT3B0aW9ucyk6IE5neHNDb25maWcge1xyXG4gIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24obmV3IE5neHNDb25maWcoKSwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIGNvbmZpZztcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFJPT1RfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxNb2R1bGVPcHRpb25zPignUk9PVF9PUFRJT05TJyk7XHJcblxyXG4vKipcclxuICogTmd4cyBNb2R1bGVcclxuICovXHJcbkBOZ01vZHVsZSh7fSlcclxuZXhwb3J0IGNsYXNzIE5neHNNb2R1bGUge1xyXG4gIC8qKlxyXG4gICAqIFJvb3QgbW9kdWxlIGZhY3RvcnlcclxuICAgKi9cclxuICBzdGF0aWMgZm9yUm9vdChzdGF0ZXM6IGFueVtdID0gW10sIG9wdGlvbnM6IE1vZHVsZU9wdGlvbnMgPSB7fSk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5neHNSb290TW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBTdGF0ZUZhY3RvcnksXHJcbiAgICAgICAgU3RhdGVDb250ZXh0RmFjdG9yeSxcclxuICAgICAgICBBY3Rpb25zLFxyXG4gICAgICAgIEludGVybmFsQWN0aW9ucyxcclxuICAgICAgICBJbnRlcm5hbERpc3BhdGNoZXIsXHJcbiAgICAgICAgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgICAgICBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyxcclxuICAgICAgICBTdG9yZSxcclxuICAgICAgICBTdGF0ZVN0cmVhbSxcclxuICAgICAgICBTZWxlY3RGYWN0b3J5LFxyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIsXHJcbiAgICAgICAgLi4uc3RhdGVzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IFJPT1RfU1RBVEVfVE9LRU4sXHJcbiAgICAgICAgICB1c2VWYWx1ZTogc3RhdGVzXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwcm92aWRlOiBST09UX09QVElPTlMsXHJcbiAgICAgICAgICB1c2VWYWx1ZTogb3B0aW9uc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogTmd4c0NvbmZpZyxcclxuICAgICAgICAgIHVzZUZhY3Rvcnk6IG5neHNDb25maWdGYWN0b3J5LFxyXG4gICAgICAgICAgZGVwczogW1JPT1RfT1BUSU9OU11cclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGZWF0dXJlIG1vZHVsZSBmYWN0b3J5XHJcbiAgICovXHJcbiAgc3RhdGljIGZvckZlYXR1cmUoc3RhdGVzOiBhbnlbXSk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5neHNGZWF0dXJlTW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBTdGF0ZUZhY3RvcnksXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlcixcclxuICAgICAgICAuLi5zdGF0ZXMsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogRkVBVFVSRV9TVEFURV9UT0tFTixcclxuICAgICAgICAgIG11bHRpOiB0cnVlLFxyXG4gICAgICAgICAgdXNlVmFsdWU6IHN0YXRlc1xyXG4gICAgICAgIH1cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgZW5zdXJlU3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IEFjdGlvbk9wdGlvbnMgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0ZXMgYSBtZXRob2Qgd2l0aCBhIGFjdGlvbiBpbmZvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBBY3Rpb24oYWN0aW9uczogYW55IHwgYW55W10sIG9wdGlvbnM/OiBBY3Rpb25PcHRpb25zKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55LCBuYW1lOiBzdHJpbmcsIGRlc2NyaXB0b3I6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPGFueT4pIHtcclxuICAgIGNvbnN0IG1ldGEgPSBlbnN1cmVTdG9yZU1ldGFkYXRhKHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFjdGlvbnMpKSB7XHJcbiAgICAgIGFjdGlvbnMgPSBbYWN0aW9uc107XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xyXG4gICAgICBjb25zdCB0eXBlID0gYWN0aW9uLnR5cGU7XHJcblxyXG4gICAgICBpZiAoIWFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3Rpb24gJHthY3Rpb24ubmFtZX0gaXMgbWlzc2luZyBhIHN0YXRpYyBcInR5cGVcIiBwcm9wZXJ0eWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW1ldGEuYWN0aW9uc1t0eXBlXSkge1xyXG4gICAgICAgIG1ldGEuYWN0aW9uc1t0eXBlXSA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtZXRhLmFjdGlvbnNbdHlwZV0ucHVzaCh7XHJcbiAgICAgICAgZm46IG5hbWUsXHJcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fSxcclxuICAgICAgICB0eXBlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgZW5zdXJlU3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IFN0b3JlT3B0aW9ucywgTUVUQV9LRVkgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuXHJcbmNvbnN0IHN0YXRlTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXlthLXpBLVowLTlfXSskJyk7XHJcblxyXG4vKipcclxuICogRXJyb3IgbWVzc2FnZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhdGVOYW1lRXJyb3JNZXNzYWdlID0gbmFtZSA9PlxyXG4gIGAke25hbWV9IGlzIG5vdCBhIHZhbGlkIHN0YXRlIG5hbWUuIEl0IG5lZWRzIHRvIGJlIGEgdmFsaWQgb2JqZWN0IHByb3BlcnR5IG5hbWUuYDtcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0ZXMgYSBjbGFzcyB3aXRoIG5neHMgc3RhdGUgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU3RhdGU8VD4ob3B0aW9uczogU3RvcmVPcHRpb25zPFQ+KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55KSB7XHJcbiAgICBjb25zdCBtZXRhID0gZW5zdXJlU3RvcmVNZXRhZGF0YSh0YXJnZXQpO1xyXG5cclxuICAgIC8vIEhhbmRsZSBpbmhlcml0YW5jZVxyXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpLmhhc093blByb3BlcnR5KE1FVEFfS0VZKSkge1xyXG4gICAgICBjb25zdCBwYXJlbnRNZXRhID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClbTUVUQV9LRVldO1xyXG5cclxuICAgICAgbWV0YS5hY3Rpb25zID0ge1xyXG4gICAgICAgIC4uLm1ldGEuYWN0aW9ucyxcclxuICAgICAgICAuLi5wYXJlbnRNZXRhLmFjdGlvbnNcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBtZXRhLmNoaWxkcmVuID0gb3B0aW9ucy5jaGlsZHJlbjtcclxuICAgIG1ldGEuZGVmYXVsdHMgPSBvcHRpb25zLmRlZmF1bHRzO1xyXG4gICAgbWV0YS5uYW1lID0gb3B0aW9ucy5uYW1lO1xyXG5cclxuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGVzIG11c3QgcmVnaXN0ZXIgYSAnbmFtZScgcHJvcGVydHlgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXN0YXRlTmFtZVJlZ2V4LnRlc3Qob3B0aW9ucy5uYW1lKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RhdGVOYW1lRXJyb3JNZXNzYWdlKG9wdGlvbnMubmFtZSkpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICcuLi91dGlscy9zZWxlY3Rvci11dGlscyc7XHJcblxyXG4vKipcclxuICogRGVjb3JhdG9yIGZvciBtZW1vaXppbmcgYSBzdGF0ZSBzZWxlY3Rvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3RvcihzZWxlY3RvcnM/OiBhbnlbXSkge1xyXG4gIHJldHVybiAodGFyZ2V0OiBhbnksIGtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpID0+IHtcclxuICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsRm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xyXG5cclxuICAgICAgY29uc3QgbWVtb2l6ZWRGbiA9IGNyZWF0ZVNlbGVjdG9yKFxyXG4gICAgICAgIHNlbGVjdG9ycyxcclxuICAgICAgICBvcmlnaW5hbEZuLFxyXG4gICAgICAgIHsgY29udGFpbmVyQ2xhc3M6IHRhcmdldCwgc2VsZWN0b3JOYW1lOiBrZXkgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgcmV0dXJuIG1lbW9pemVkRm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWxlY3RvcnMgb25seSB3b3JrIG9uIG1ldGhvZHMnKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBR0EsTUFBYSxnQkFBZ0IsR0FBRyxJQUFJLGNBQWMsQ0FBTSxrQkFBa0IsQ0FBQzs7QUFDM0UsTUFBYSxtQkFBbUIs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