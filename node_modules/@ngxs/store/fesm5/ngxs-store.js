import { InjectionToken, Injectable, NgZone, Optional, SkipSelf, Inject, ErrorHandler, isDevMode, Injector, NgModule } from '@angular/core';
import { __spread, __assign, __extends, __values } from 'tslib';
import { map, filter, shareReplay, exhaustMap, take, takeUntil, catchError, mergeMap, defaultIfEmpty, distinctUntilChanged } from 'rxjs/operators';
import { Observable, Subject, BehaviorSubject, of, forkJoin, empty, throwError, from } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
/** @type {?} */
var FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
/** @type {?} */
var META_KEY = 'NGXS_META';
/** @type {?} */
var SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
/** @type {?} */
var NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');
/**
 * The NGXS config settings.
 */
var  /**
 * The NGXS config settings.
 */
NgxsConfig = /** @class */ (function () {
    function NgxsConfig() {
        this.compatibility = {
            strictContentSecurityPolicy: false
        };
    }
    return NgxsConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        var defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            selectFromAppState: null,
            children: [],
            instance: null
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function getStoreMetadata(target) {
    return target[META_KEY];
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        var defaultMetadata = {
            selectFromAppState: null,
            originalFn: null,
            containerClass: null,
            selectorName: null
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    var copyOfPaths = __spread(paths);
    return function (obj) { return copyOfPaths.reduce(function (acc, part) { return acc && acc[part]; }, obj); };
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    var segments = paths;
    /** @type {?} */
    var seg = 'store.' + segments[0];
    /** @type {?} */
    var i = 0;
    /** @type {?} */
    var l = segments.length;
    /** @type {?} */
    var expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    var fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
function buildGraph(stateClasses) {
    /** @type {?} */
    var findName = function (stateClass) {
        /** @type {?} */
        var meta = stateClasses.find(function (g) { return g === stateClass; });
        if (!meta) {
            throw new Error("Child state not found: " + stateClass);
        }
        if (!meta[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        return meta[META_KEY].name;
    };
    return stateClasses.reduce(function (result, stateClass) {
        if (!stateClass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        var _a = stateClass[META_KEY], name = _a.name, children = _a.children;
        result[name] = (children || []).map(findName);
        return result;
    }, {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
function nameToState(states) {
    return states.reduce(function (result, stateClass) {
        if (!stateClass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        /** @type {?} */
        var meta = stateClass[META_KEY];
        result[meta.name] = stateClass;
        return result;
    }, {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
function findFullParentPath(obj, newObj) {
    if (newObj === void 0) { newObj = {}; }
    /** @type {?} */
    var visit = function (child, keyToFind) {
        for (var key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                var parent_1 = visit(child, key);
                return parent_1 !== null ? parent_1 + "." + key : key;
            }
        }
        return null;
    };
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            var parent_2 = visit(obj, key);
            newObj[key] = parent_2 ? parent_2 + "." + key : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
function topologicalSort(graph) {
    /** @type {?} */
    var sorted = [];
    /** @type {?} */
    var visited = {};
    /** @type {?} */
    var visit = function (name, ancestors) {
        if (ancestors === void 0) { ancestors = []; }
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach(function (dep) {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error("Circular dependency '" + dep + "' is required by '" + name + "': " + ancestors.join(' -> '));
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        });
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    };
    Object.keys(graph).forEach(function (k) { return visit(k); });
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns the type from an action instance.
 * @ignore
 * @param {?} action
 * @return {?}
 */
function getActionTypeFromInstance(action) {
    if (action.constructor && action.constructor.type) {
        return action.constructor.type;
    }
    return action.type;
}
/**
 * Matches a action
 * @ignore
 * @param {?} action1
 * @return {?}
 */
function actionMatcher(action1) {
    /** @type {?} */
    var type1 = getActionTypeFromInstance(action1);
    return function (action2) {
        return type1 === getActionTypeFromInstance(action2);
    };
}
/**
 * Set a deeply nested value. Example:
 *
 *   setValue({ foo: { bar: { eat: false } } },
 *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
 *
 * While it traverses it also creates new objects from top down.
 *
 * @ignore
 * @type {?}
 */
var setValue = function (obj, prop, val) {
    obj = __assign({}, obj);
    /** @type {?} */
    var split = prop.split('.');
    /** @type {?} */
    var lastIndex = split.length - 1;
    split.reduce(function (acc, part, index) {
        if (index === lastIndex) {
            acc[part] = val;
        }
        else {
            acc[part] = Array.isArray(acc[part]) ? __spread(acc[part]) : __assign({}, acc[part]);
        }
        return acc && acc[part];
    }, obj);
    return obj;
};
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @type {?}
 */
var getValue = function (obj, prop) {
    return prop.split('.').reduce(function (acc, part) { return acc && acc[part]; }, obj);
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will grab actions that have just been dispatched as well as actions that have completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofAction() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    return ofActionOperator(allowedTypes);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been dispatched
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionDispatched() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    return ofActionOperator(allowedTypes, "DISPATCHED" /* Dispatched */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been successfully completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionSuccessful() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    return ofActionOperator(allowedTypes, "SUCCESSFUL" /* Successful */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been canceled
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionCanceled() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    return ofActionOperator(allowedTypes, "CANCELED" /* Canceled */);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just thrown an error
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionErrored() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    return ofActionOperator(allowedTypes, "ERRORED" /* Errored */);
}
/**
 * @param {?} allowedTypes
 * @param {?=} status
 * @return {?}
 */
function ofActionOperator(allowedTypes, status) {
    /** @type {?} */
    var allowedMap = createAllowedMap(allowedTypes);
    return function (o) {
        return o.pipe(filterStatus(allowedMap, status), mapAction());
    };
}
/**
 * @param {?} allowedTypes
 * @param {?=} status
 * @return {?}
 */
function filterStatus(allowedTypes, status) {
    return filter(function (ctx) {
        /** @type {?} */
        var actionType = getActionTypeFromInstance(ctx.action);
        /** @type {?} */
        var type = allowedTypes[actionType];
        return status ? type && ctx.status === status : type;
    });
}
/**
 * @return {?}
 */
function mapAction() {
    return map(function (ctx) { return ctx.action; });
}
/**
 * @param {?} types
 * @return {?}
 */
function createAllowedMap(types) {
    return types.reduce(function (acc, klass) {
        acc[getActionTypeFromInstance(klass)] = true;
        return acc;
    }, {});
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Operator to run the `subscribe` in a Angular zone.
 * @template T
 * @param {?} zone
 * @return {?}
 */
function enterZone(zone) {
    return function (source) {
        return new Observable(function (sink) {
            return source.subscribe({
                next: /**
                 * @param {?} x
                 * @return {?}
                 */
                function (x) {
                    zone.run(function () { return sink.next(x); });
                },
                error: /**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    zone.run(function () { return sink.error(e); });
                },
                complete: /**
                 * @return {?}
                 */
                function () {
                    zone.run(function () { return sink.complete(); });
                }
            });
        });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
var  /**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
OrderedSubject = /** @class */ (function (_super) {
    __extends(OrderedSubject, _super);
    function OrderedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._itemQueue = [];
        _this._busyPushingNext = false;
        return _this;
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    OrderedSubject.prototype.next = /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._busyPushingNext) {
            this._itemQueue.unshift(value);
            return;
        }
        this._busyPushingNext = true;
        _super.prototype.next.call(this, value);
        while (this._itemQueue.length > 0) {
            /** @type {?} */
            var nextValue = this._itemQueue.pop();
            _super.prototype.next.call(this, nextValue);
        }
        this._busyPushingNext = false;
    };
    return OrderedSubject;
}(Subject));
/**
 * Internal Action stream that is emitted anytime an action is dispatched.
 */
var InternalActions = /** @class */ (function (_super) {
    __extends(InternalActions, _super);
    function InternalActions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InternalActions.decorators = [
        { type: Injectable }
    ];
    return InternalActions;
}(OrderedSubject));
/**
 * Action stream that is emitted anytime an action is dispatched.
 *
 * You can listen to this in services to react without stores.
 */
var Actions = /** @class */ (function (_super) {
    __extends(Actions, _super);
    function Actions(actions$, ngZone) {
        return _super.call(this, function (observer) {
            actions$
                .pipe(enterZone(ngZone))
                .subscribe(function (res) { return observer.next(res); }, function (err) { return observer.error(err); }, function () { return observer.complete(); });
        }) || this;
    }
    Actions.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Actions.ctorParameters = function () { return [
        { type: InternalActions },
        { type: NgZone }
    ]; };
    return Actions;
}(Observable));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Composes a array of functions from left to right. Example:
 *
 *      compose([fn, final])(state, action);
 *
 * then the funcs have a signature like:
 *
 *      function fn (state, action, next) {
 *          console.log('here', state, action, next);
 *          return next(state, action);
 *      }
 *
 *      function final (state, action) {
 *          console.log('here', state, action);
 *          return state;
 *      }
 *
 * the last function should not call `next`.
 *
 * @ignore
 * @type {?}
 */
var compose = function (funcs) { return function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    /** @type {?} */
    var curr = funcs.shift();
    return curr.apply(void 0, __spread(args, [function () {
            var nextArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nextArgs[_i] = arguments[_i];
            }
            return compose(funcs).apply(void 0, __spread(nextArgs));
        }]));
}; };

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * BehaviorSubject of the entire state.
 * @ignore
 */
var StateStream = /** @class */ (function (_super) {
    __extends(StateStream, _super);
    function StateStream() {
        return _super.call(this, {}) || this;
    }
    StateStream.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateStream.ctorParameters = function () { return []; };
    return StateStream;
}(BehaviorSubject));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Plugin manager class
 * @ignore
 */
var PluginManager = /** @class */ (function () {
    function PluginManager(_parentManager, _plugins) {
        this._parentManager = _parentManager;
        this._plugins = _plugins;
        this.plugins = [];
        this.register();
    }
    /**
     * @private
     * @return {?}
     */
    PluginManager.prototype.register = /**
     * @private
     * @return {?}
     */
    function () {
        var _a;
        if (!this._plugins) {
            return;
        }
        this.plugins = this._plugins.map(function (plugin) {
            if (plugin.handle) {
                return plugin.handle.bind(plugin);
            }
            else {
                return plugin;
            }
        });
        if (this._parentManager) {
            (_a = this._parentManager.plugins).push.apply(_a, __spread(this.plugins));
        }
    };
    PluginManager.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    PluginManager.ctorParameters = function () { return [
        { type: PluginManager, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: Array, decorators: [{ type: Inject, args: [NGXS_PLUGINS,] }, { type: Optional }] }
    ]; };
    return PluginManager;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal Action result stream that is emitted when an action is completed.
 * This is used as a method of returning the action result to the dispatcher
 * for the observable returned by the dispatch(...) call.
 * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.
 */
var InternalDispatchedActionResults = /** @class */ (function (_super) {
    __extends(InternalDispatchedActionResults, _super);
    function InternalDispatchedActionResults() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InternalDispatchedActionResults.decorators = [
        { type: Injectable }
    ];
    return InternalDispatchedActionResults;
}(Subject));
var InternalDispatcher = /** @class */ (function () {
    function InternalDispatcher(_errorHandler, _actions, _actionResults, _pluginManager, _stateStream, _ngZone) {
        this._errorHandler = _errorHandler;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._pluginManager = _pluginManager;
        this._stateStream = _stateStream;
        this._ngZone = _ngZone;
    }
    /**
     * Dispatches event(s).
     */
    /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    InternalDispatcher.prototype.dispatch = /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var result = this._ngZone.runOutsideAngular(function () {
            if (Array.isArray(event)) {
                return forkJoin(event.map(function (a) { return _this.dispatchSingle(a); }));
            }
            else {
                return _this.dispatchSingle(event);
            }
        });
        result.subscribe({
            error: function (error) { return _this._ngZone.run(function () { return _this._errorHandler.handleError(error); }); }
        });
        return result.pipe(enterZone(this._ngZone));
    };
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    InternalDispatcher.prototype.dispatchSingle = /**
     * @private
     * @param {?} action
     * @return {?}
     */
    function (action) {
        var _this = this;
        /** @type {?} */
        var prevState = this._stateStream.getValue();
        /** @type {?} */
        var plugins = this._pluginManager.plugins;
        return ((/** @type {?} */ (compose(__spread(plugins, [
            function (nextState, nextAction) {
                if (nextState !== prevState) {
                    _this._stateStream.next(nextState);
                }
                /** @type {?} */
                var actionResult$ = _this.getActionResultStream(nextAction);
                actionResult$.subscribe(function (ctx) { return _this._actions.next(ctx); });
                _this._actions.next({ action: nextAction, status: "DISPATCHED" /* Dispatched */ });
                return _this.createDispatchObservable(actionResult$);
            }
        ]))(prevState, action)))).pipe(shareReplay());
    };
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    InternalDispatcher.prototype.getActionResultStream = /**
     * @private
     * @param {?} action
     * @return {?}
     */
    function (action) {
        return this._actionResults.pipe(filter(function (ctx) { return ctx.action === action && ctx.status !== "DISPATCHED" /* Dispatched */; }), take(1), shareReplay());
    };
    /**
     * @private
     * @param {?} actionResult$
     * @return {?}
     */
    InternalDispatcher.prototype.createDispatchObservable = /**
     * @private
     * @param {?} actionResult$
     * @return {?}
     */
    function (actionResult$) {
        var _this = this;
        return actionResult$
            .pipe(exhaustMap(function (ctx) {
            switch (ctx.status) {
                case "SUCCESSFUL" /* Successful */:
                    return of(_this._stateStream.getValue());
                case "ERRORED" /* Errored */:
                    return throwError(ctx.error);
                default:
                    return empty();
            }
        }))
            .pipe(shareReplay());
    };
    InternalDispatcher.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    InternalDispatcher.ctorParameters = function () { return [
        { type: ErrorHandler },
        { type: InternalActions },
        { type: InternalDispatchedActionResults },
        { type: PluginManager },
        { type: StateStream },
        { type: NgZone }
    ]; };
    return InternalDispatcher;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Object freeze code
 * https://github.com/jsdf/deep-freeze
 * @type {?}
 */
var deepFreeze = function (o) {
    Object.freeze(o);
    /** @type {?} */
    var oIsFunction = typeof o === 'function';
    /** @type {?} */
    var hasOwnProp = Object.prototype.hasOwnProperty;
    Object.getOwnPropertyNames(o).forEach(function (prop) {
        if (hasOwnProp.call(o, prop) &&
            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
            o[prop] !== null &&
            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
            !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
        }
    });
    return o;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State Context factory class
 * @ignore
 */
var InternalStateOperations = /** @class */ (function () {
    function InternalStateOperations(_stateStream, _dispatcher, _config) {
        this._stateStream = _stateStream;
        this._dispatcher = _dispatcher;
        this._config = _config;
        this.verifyDevMode();
    }
    /**
     * Returns the root state operators.
     */
    /**
     * Returns the root state operators.
     * @return {?}
     */
    InternalStateOperations.prototype.getRootStateOperations = /**
     * Returns the root state operators.
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var rootStateOperations = {
            getState: function () { return _this._stateStream.getValue(); },
            setState: function (newState) { return _this._stateStream.next(newState); },
            dispatch: function (actions) { return _this._dispatcher.dispatch(actions); }
        };
        if (this._config.developmentMode) {
            return this.ensureStateAndActionsAreImmutable(rootStateOperations);
        }
        return rootStateOperations;
    };
    /**
     * @private
     * @return {?}
     */
    InternalStateOperations.prototype.verifyDevMode = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isNgxsDevMode = this._config.developmentMode;
        /** @type {?} */
        var isNgDevMode = isDevMode();
        /** @type {?} */
        var incorrectProduction = !isNgDevMode && isNgxsDevMode;
        /** @type {?} */
        var incorrectDevelopment = isNgDevMode && !isNgxsDevMode;
        /** @type {?} */
        var example = 'NgxsModule.forRoot(states, { developmentMode: !environment.production })';
        if (incorrectProduction) {
            console.warn('Angular is running in production mode but NGXS is still running in the development mode!\n', 'Please set developmentMode to false on the NgxsModule options when in production mode.\n', example);
        }
        else if (incorrectDevelopment) {
            console.warn('RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\n', example);
        }
    };
    /**
     * @private
     * @param {?} root
     * @return {?}
     */
    InternalStateOperations.prototype.ensureStateAndActionsAreImmutable = /**
     * @private
     * @param {?} root
     * @return {?}
     */
    function (root) {
        return {
            getState: function () { return root.getState(); },
            setState: function (value) {
                /** @type {?} */
                var frozenValue = deepFreeze(value);
                return root.setState(frozenValue);
            },
            dispatch: function (actions) {
                return root.dispatch(actions);
            }
        };
    };
    InternalStateOperations.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    InternalStateOperations.ctorParameters = function () { return [
        { type: StateStream },
        { type: InternalDispatcher },
        { type: NgxsConfig }
    ]; };
    return InternalStateOperations;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State Context factory class
 * @ignore
 */
var StateContextFactory = /** @class */ (function () {
    function StateContextFactory(_internalStateOperations) {
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Create the state context
     */
    /**
     * Create the state context
     * @param {?} metadata
     * @return {?}
     */
    StateContextFactory.prototype.createStateContext = /**
     * Create the state context
     * @param {?} metadata
     * @return {?}
     */
    function (metadata) {
        /** @type {?} */
        var root = this._internalStateOperations.getRootStateOperations();
        return {
            getState: /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var state = root.getState();
                return getValue(state, metadata.depth);
            },
            patchState: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                /** @type {?} */
                var isArray = Array.isArray(val);
                /** @type {?} */
                var isPrimitive = typeof val !== 'object';
                if (isArray) {
                    throw new Error('Patching arrays is not supported.');
                }
                else if (isPrimitive) {
                    throw new Error('Patching primitives is not supported.');
                }
                /** @type {?} */
                var state = root.getState();
                /** @type {?} */
                var local = getValue(state, metadata.depth);
                /** @type {?} */
                var clone = __assign({}, local);
                for (var k in val) {
                    clone[k] = val[k];
                }
                /** @type {?} */
                var newState = setValue(state, metadata.depth, clone);
                root.setState(newState);
                return newState;
            },
            setState: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                /** @type {?} */
                var state = root.getState();
                state = setValue(state, metadata.depth, val);
                root.setState(state);
                return state;
            },
            dispatch: /**
             * @param {?} actions
             * @return {?}
             */
            function (actions) {
                return root.dispatch(actions);
            }
        };
    };
    StateContextFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateContextFactory.ctorParameters = function () { return [
        { type: InternalStateOperations }
    ]; };
    return StateContextFactory;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State factory class
 * @ignore
 */
var StateFactory = /** @class */ (function () {
    function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._states = [];
        this._connected = false;
    }
    Object.defineProperty(StateFactory.prototype, "states", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.states : this._states;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a new state to the global defs.
     */
    /**
     * Add a new state to the global defs.
     * @param {?} oneOrManyStateClasses
     * @return {?}
     */
    StateFactory.prototype.add = /**
     * Add a new state to the global defs.
     * @param {?} oneOrManyStateClasses
     * @return {?}
     */
    function (oneOrManyStateClasses) {
        var e_1, _a, _b;
        /** @type {?} */
        var stateClasses;
        if (!Array.isArray(oneOrManyStateClasses)) {
            stateClasses = [oneOrManyStateClasses];
        }
        else {
            stateClasses = oneOrManyStateClasses;
        }
        /** @type {?} */
        var stateGraph = buildGraph(stateClasses);
        /** @type {?} */
        var sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        var depths = findFullParentPath(stateGraph);
        /** @type {?} */
        var nameGraph = nameToState(stateClasses);
        /** @type {?} */
        var mappedStores = [];
        var _loop_1 = function (name_1) {
            /** @type {?} */
            var stateClass = nameGraph[name_1];
            if (!stateClass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            /** @type {?} */
            var depth = depths[name_1];
            var actions = stateClass[META_KEY].actions;
            var defaults = stateClass[META_KEY].defaults;
            stateClass[META_KEY].path = depth;
            stateClass[META_KEY].selectFromAppState = propGetter(depth.split('.'), this_1._config);
            // ensure our store hasn't already been added
            // but dont throw since it could be lazy
            // loaded from different paths
            /** @type {?} */
            var has = this_1.states.find(function (s) { return s.name === name_1; });
            if (!has) {
                // create new instance of defaults
                if (Array.isArray(defaults)) {
                    defaults = __spread(defaults);
                }
                else if (isObject(defaults)) {
                    defaults = __assign({}, defaults);
                }
                else if (defaults === undefined) {
                    defaults = {};
                }
                /** @type {?} */
                var instance = this_1._injector.get(stateClass);
                mappedStores.push({
                    actions: actions,
                    instance: instance,
                    defaults: defaults,
                    name: name_1,
                    depth: depth
                });
            }
        };
        var this_1 = this;
        try {
            for (var sortedStates_1 = __values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                var name_1 = sortedStates_1_1.value;
                _loop_1(name_1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return)) _a.call(sortedStates_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        (_b = this.states).push.apply(_b, __spread(mappedStores));
        return mappedStores;
    };
    /**
     * Add a set of states to the store and return the defaulsts
     */
    /**
     * Add a set of states to the store and return the defaulsts
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addAndReturnDefaults = /**
     * Add a set of states to the store and return the defaulsts
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        if (stateClasses) {
            /** @type {?} */
            var states = this.add(stateClasses);
            /** @type {?} */
            var defaults = states.reduce(function (result, meta) { return setValue(result, meta.depth, meta.defaults); }, {});
            return { defaults: defaults, states: states };
        }
    };
    /**
     * Bind the actions to the handlers
     */
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    StateFactory.prototype.connectActionHandlers = /**
     * Bind the actions to the handlers
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._connected)
            return;
        this._actions
            .pipe(filter(function (ctx) { return ctx.status === "DISPATCHED" /* Dispatched */; }), mergeMap(function (_a) {
            var action = _a.action;
            return _this.invokeActions(_this._actions, action).pipe(map(function () { return (/** @type {?} */ ({ action: action, status: "SUCCESSFUL" /* Successful */ })); }), defaultIfEmpty((/** @type {?} */ ({ action: action, status: "CANCELED" /* Canceled */ }))), catchError(function (error) { return of((/** @type {?} */ ({ action: action, status: "ERRORED" /* Errored */, error: error }))); }));
        }))
            .subscribe(function (ctx) { return _this._actionResults.next(ctx); });
        this._connected = true;
    };
    /**
     * Invoke the init function on the states.
     */
    /**
     * Invoke the init function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    StateFactory.prototype.invokeInit = /**
     * Invoke the init function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    function (stateMetadatas) {
        var e_2, _a;
        try {
            for (var stateMetadatas_1 = __values(stateMetadatas), stateMetadatas_1_1 = stateMetadatas_1.next(); !stateMetadatas_1_1.done; stateMetadatas_1_1 = stateMetadatas_1.next()) {
                var metadata = stateMetadatas_1_1.value;
                /** @type {?} */
                var instance = metadata.instance;
                if (instance.ngxsOnInit) {
                    /** @type {?} */
                    var stateContext = this.createStateContext(metadata);
                    instance.ngxsOnInit(stateContext);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (stateMetadatas_1_1 && !stateMetadatas_1_1.done && (_a = stateMetadatas_1.return)) _a.call(stateMetadatas_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * Invoke actions on the states.
     */
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    StateFactory.prototype.invokeActions = /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    function (actions$, action) {
        var e_3, _a, e_4, _b;
        /** @type {?} */
        var results = [];
        try {
            for (var _c = __values(this.states), _d = _c.next(); !_d.done; _d = _c.next()) {
                var metadata = _d.value;
                /** @type {?} */
                var type = getActionTypeFromInstance(action);
                /** @type {?} */
                var actionMetas = metadata.actions[type];
                if (actionMetas) {
                    try {
                        for (var actionMetas_1 = __values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                            var actionMeta = actionMetas_1_1.value;
                            /** @type {?} */
                            var stateContext = this.createStateContext(metadata);
                            try {
                                /** @type {?} */
                                var result = metadata.instance[actionMeta.fn](stateContext, action);
                                if (result instanceof Promise) {
                                    result = from(result);
                                }
                                if (result instanceof Observable) {
                                    result = result.pipe(actionMeta.options.cancelUncompleted
                                        ? takeUntil(actions$.pipe(ofActionDispatched(action)))
                                        : map(function (r) { return r; })); // map acts like a noop
                                }
                                else {
                                    result = of({}).pipe(shareReplay());
                                }
                                results.push(result);
                            }
                            catch (e) {
                                results.push(throwError(e));
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (actionMetas_1_1 && !actionMetas_1_1.done && (_b = actionMetas_1.return)) _b.call(actionMetas_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    };
    /**
     * Create the state context
     */
    /**
     * Create the state context
     * @private
     * @param {?} metadata
     * @return {?}
     */
    StateFactory.prototype.createStateContext = /**
     * Create the state context
     * @private
     * @param {?} metadata
     * @return {?}
     */
    function (metadata) {
        return this._stateContextFactory.createStateContext(metadata);
    };
    StateFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateFactory.ctorParameters = function () { return [
        { type: Injector },
        { type: NgxsConfig },
        { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: InternalActions },
        { type: InternalDispatchedActionResults },
        { type: StateContextFactory }
    ]; };
    return StateFactory;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function defaultEqualityCheck(a, b) {
    return a === b;
}
/**
 * @param {?} equalityCheck
 * @param {?} prev
 * @param {?} next
 * @return {?}
 */
function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
        return false;
    }
    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
    /** @type {?} */
    var length = prev.length;
    for (var i = 0; i < length; i++) {
        if (!equalityCheck(prev[i], next[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Memoize a function on its last inputs only.
 * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js
 *
 * @ignore
 * @param {?} func
 * @param {?=} equalityCheck
 * @return {?}
 */
function memoize(func, equalityCheck) {
    if (equalityCheck === void 0) { equalityCheck = defaultEqualityCheck; }
    /** @type {?} */
    var lastArgs = null;
    /** @type {?} */
    var lastResult = null;
    // we reference arguments instead of spreading them for performance reasons
    return (/** @type {?} */ (function memoized() {
        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
            // apply arguments instead of spreading for performance.
            lastResult = func.apply(null, arguments);
        }
        lastArgs = arguments;
        return lastResult;
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Function for creating a selector
 * @param {?} selectors The selectors to use to create the arguments of this function
 * @param {?} originalFn The original function being made into a selector
 * @param {?=} creationMetadata
 * @return {?}
 */
function createSelector(selectors, originalFn, creationMetadata) {
    /** @type {?} */
    var wrappedFn = function wrappedSelectorFn() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        /** @type {?} */
        var returnValue = originalFn.apply(void 0, __spread(args));
        if (returnValue instanceof Function) {
            /** @type {?} */
            var innerMemoizedFn = memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    };
    /** @type {?} */
    var memoizedFn = memoize(wrappedFn);
    /** @type {?} */
    var containerClass = creationMetadata && creationMetadata.containerClass;
    /** @type {?} */
    var fn = function (state) {
        /** @type {?} */
        var results = [];
        /** @type {?} */
        var selectorsToApply = [];
        if (containerClass) {
            // If we are on a state class, add it as the first selector parameter
            /** @type {?} */
            var metadata = getStoreMetadata(containerClass);
            if (metadata) {
                selectorsToApply.push(containerClass);
            }
        }
        if (selectors) {
            selectorsToApply.push.apply(selectorsToApply, __spread(selectors));
        }
        // Determine arguments from the app state using the selectors
        if (selectorsToApply) {
            results.push.apply(results, __spread(selectorsToApply.map(function (a) { return getSelectorFn(a)(state); })));
        }
        // if the lambda tries to access a something on the
        // state that doesn't exist, it will throw a TypeError.
        // since this is quite usual behaviour, we simply return undefined if so.
        try {
            return memoizedFn.apply(void 0, __spread(results));
        }
        catch (ex) {
            if (ex instanceof TypeError) {
                return undefined;
            }
            throw ex;
        }
    };
    /** @type {?} */
    var selectorMetaData = ensureSelectorMetadata(memoizedFn);
    selectorMetaData.originalFn = originalFn;
    selectorMetaData.selectFromAppState = fn;
    if (creationMetadata) {
        selectorMetaData.containerClass = creationMetadata.containerClass;
        selectorMetaData.selectorName = creationMetadata.selectorName;
    }
    return memoizedFn;
}
/**
 * This function gets the selector function to be used to get the selected slice from the app state
 * @ignore
 * @param {?} selector
 * @return {?}
 */
function getSelectorFn(selector) {
    /** @type {?} */
    var metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
    return (metadata && metadata.selectFromAppState) || selector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Store = /** @class */ (function () {
    function Store(_ngZone, _stateStream, _internalStateOperations) {
        this._ngZone = _ngZone;
        this._stateStream = _stateStream;
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Dispatches event(s).
     */
    /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    Store.prototype.dispatch = /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return this._internalStateOperations.getRootStateOperations().dispatch(event);
    };
    /**
     * @param {?} selector
     * @return {?}
     */
    Store.prototype.select = /**
     * @param {?} selector
     * @return {?}
     */
    function (selector) {
        /** @type {?} */
        var selectorFn = getSelectorFn(selector);
        return this._stateStream.pipe(map(selectorFn), catchError(function (err) {
            // if error is TypeError we swallow it to prevent usual errors with property access
            if (err instanceof TypeError) {
                return of(undefined);
            }
            // rethrow other errors
            throw err;
        }), distinctUntilChanged(), enterZone(this._ngZone));
    };
    /**
     * @param {?} selector
     * @return {?}
     */
    Store.prototype.selectOnce = /**
     * @param {?} selector
     * @return {?}
     */
    function (selector) {
        return this.select(selector).pipe(take(1));
    };
    /**
     * @param {?} selector
     * @return {?}
     */
    Store.prototype.selectSnapshot = /**
     * @param {?} selector
     * @return {?}
     */
    function (selector) {
        /** @type {?} */
        var selectorFn = getSelectorFn(selector);
        return selectorFn(this._stateStream.getValue());
    };
    /**
     * Allow the user to subscribe to the root of the state
     */
    /**
     * Allow the user to subscribe to the root of the state
     * @param {?=} fn
     * @return {?}
     */
    Store.prototype.subscribe = /**
     * Allow the user to subscribe to the root of the state
     * @param {?=} fn
     * @return {?}
     */
    function (fn) {
        return this._stateStream.pipe(enterZone(this._ngZone)).subscribe(fn);
    };
    /**
     * Return the raw value of the state.
     */
    /**
     * Return the raw value of the state.
     * @return {?}
     */
    Store.prototype.snapshot = /**
     * Return the raw value of the state.
     * @return {?}
     */
    function () {
        return this._internalStateOperations.getRootStateOperations().getState();
    };
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     */
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     * @param {?} state
     * @return {?}
     */
    Store.prototype.reset = /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     * @param {?} state
     * @return {?}
     */
    function (state) {
        return this._internalStateOperations.getRootStateOperations().setState(state);
    };
    Store.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Store.ctorParameters = function () { return [
        { type: NgZone },
        { type: StateStream },
        { type: InternalStateOperations }
    ]; };
    return Store;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Allows the select decorator to get access to the DI store.
 * @ignore
 */
var SelectFactory = /** @class */ (function () {
    function SelectFactory(store, config) {
        SelectFactory.store = store;
        SelectFactory.config = config;
    }
    SelectFactory.store = undefined;
    SelectFactory.config = undefined;
    SelectFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    SelectFactory.ctorParameters = function () { return [
        { type: Store },
        { type: NgxsConfig }
    ]; };
    return SelectFactory;
}());
/**
 * Decorator for selecting a slice of state from the store.
 * @param {?=} selectorOrFeature
 * @param {...?} paths
 * @return {?}
 */
function Select(selectorOrFeature) {
    var paths = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        paths[_i - 1] = arguments[_i];
    }
    return function (target, name) {
        /** @type {?} */
        var selectorFnName = '__' + name + '__selector';
        if (!selectorOrFeature) {
            // if foo$ => make it just foo
            selectorOrFeature = name.lastIndexOf('$') === name.length - 1 ? name.substring(0, name.length - 1) : name;
        }
        /** @type {?} */
        var createSelect = function (fn) {
            /** @type {?} */
            var store = SelectFactory.store;
            if (!store) {
                throw new Error('SelectFactory not connected to store!');
            }
            return store.select(fn);
        };
        /** @type {?} */
        var createSelector = function () {
            /** @type {?} */
            var config = SelectFactory.config;
            if (typeof selectorOrFeature === 'string') {
                /** @type {?} */
                var propsArray = paths.length ? __spread([selectorOrFeature], paths) : selectorOrFeature.split('.');
                return propGetter(propsArray, config);
            }
            else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {
                return propGetter(selectorOrFeature[META_KEY].path.split('.'), config);
            }
            else {
                return selectorOrFeature;
            }
        };
        if (target[selectorFnName]) {
            throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');
        }
        if (delete target[name]) {
            Object.defineProperty(target, selectorFnName, {
                writable: true,
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(target, name, {
                get: function () {
                    return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this, [createSelector()]));
                },
                enumerable: true,
                configurable: true
            });
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Init action
 */
var  /**
 * Init action
 */
InitState = /** @class */ (function () {
    function InitState() {
    }
    Object.defineProperty(InitState, "type", {
        get: /**
         * @return {?}
         */
        function () {
            // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
            return '@@INIT';
        },
        enumerable: true,
        configurable: true
    });
    return InitState;
}());
/**
 * Update action
 */
var  /**
 * Update action
 */
UpdateState = /** @class */ (function () {
    function UpdateState() {
    }
    Object.defineProperty(UpdateState, "type", {
        get: /**
         * @return {?}
         */
        function () {
            // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
            return '@@UPDATE_STATE';
        },
        enumerable: true,
        configurable: true
    });
    return UpdateState;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Root module
 * @ignore
 */
var NgxsRootModule = /** @class */ (function () {
    function NgxsRootModule(factory, internalStateOperations, store, select, states) {
        // add stores to the state graph and return their defaults
        /** @type {?} */
        var results = factory.addAndReturnDefaults(states);
        /** @type {?} */
        var stateOperations = internalStateOperations.getRootStateOperations();
        if (results) {
            // get our current stream
            /** @type {?} */
            var cur = stateOperations.getState();
            // set the state to the current + new
            stateOperations.setState(__assign({}, cur, results.defaults));
        }
        // connect our actions stream
        factory.connectActionHandlers();
        // dispatch the init action and invoke init function after
        stateOperations.dispatch(new InitState()).subscribe(function () {
            if (results) {
                factory.invokeInit(results.states);
            }
        });
    }
    NgxsRootModule.decorators = [
        { type: NgModule }
    ];
    /** @nocollapse */
    NgxsRootModule.ctorParameters = function () { return [
        { type: StateFactory },
        { type: InternalStateOperations },
        { type: Store },
        { type: SelectFactory },
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [ROOT_STATE_TOKEN,] }] }
    ]; };
    return NgxsRootModule;
}());
/**
 * Feature module
 * @ignore
 */
var NgxsFeatureModule = /** @class */ (function () {
    function NgxsFeatureModule(store, internalStateOperations, factory, states) {
        // Since FEATURE_STATE_TOKEN is a multi token, we need to
        // flatten it [[Feature1State, Feature2State], [Feature3State]]
        /** @type {?} */
        var flattenedStates = ((/** @type {?} */ ([]))).concat.apply(((/** @type {?} */ ([]))), __spread(states));
        // add stores to the state graph and return their defaults
        /** @type {?} */
        var results = factory.addAndReturnDefaults(flattenedStates);
        /** @type {?} */
        var stateOperations = internalStateOperations.getRootStateOperations();
        if (results) {
            // get our current stream
            /** @type {?} */
            var cur = stateOperations.getState();
            // set the state to the current + new
            stateOperations.setState(__assign({}, cur, results.defaults));
        }
        stateOperations.dispatch(new UpdateState()).subscribe(function () {
            if (results) {
                factory.invokeInit(results.states);
            }
        });
    }
    NgxsFeatureModule.decorators = [
        { type: NgModule, args: [{},] }
    ];
    /** @nocollapse */
    NgxsFeatureModule.ctorParameters = function () { return [
        { type: Store },
        { type: InternalStateOperations },
        { type: StateFactory },
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [FEATURE_STATE_TOKEN,] }] }
    ]; };
    return NgxsFeatureModule;
}());
/**
 * @param {?} options
 * @return {?}
 */
function ngxsConfigFactory(options) {
    /** @type {?} */
    var config = Object.assign(new NgxsConfig(), options);
    return config;
}
/** @type {?} */
var ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');
/**
 * Ngxs Module
 */
var NgxsModule = /** @class */ (function () {
    function NgxsModule() {
    }
    /**
     * Root module factory
     */
    /**
     * Root module factory
     * @param {?=} states
     * @param {?=} options
     * @return {?}
     */
    NgxsModule.forRoot = /**
     * Root module factory
     * @param {?=} states
     * @param {?=} options
     * @return {?}
     */
    function (states, options) {
        if (states === void 0) { states = []; }
        if (options === void 0) { options = {}; }
        return {
            ngModule: NgxsRootModule,
            providers: __spread([
                StateFactory,
                StateContextFactory,
                Actions,
                InternalActions,
                InternalDispatcher,
                InternalDispatchedActionResults,
                InternalStateOperations,
                Store,
                StateStream,
                SelectFactory,
                PluginManager
            ], states, [
                {
                    provide: ROOT_STATE_TOKEN,
                    useValue: states
                },
                {
                    provide: ROOT_OPTIONS,
                    useValue: options
                },
                {
                    provide: NgxsConfig,
                    useFactory: ngxsConfigFactory,
                    deps: [ROOT_OPTIONS]
                }
            ])
        };
    };
    /**
     * Feature module factory
     */
    /**
     * Feature module factory
     * @param {?} states
     * @return {?}
     */
    NgxsModule.forFeature = /**
     * Feature module factory
     * @param {?} states
     * @return {?}
     */
    function (states) {
        return {
            ngModule: NgxsFeatureModule,
            providers: __spread([
                StateFactory,
                PluginManager
            ], states, [
                {
                    provide: FEATURE_STATE_TOKEN,
                    multi: true,
                    useValue: states
                }
            ])
        };
    };
    NgxsModule.decorators = [
        { type: NgModule, args: [{},] }
    ];
    return NgxsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorates a method with a action information.
 * @param {?} actions
 * @param {?=} options
 * @return {?}
 */
function Action(actions, options) {
    return function (target, name, descriptor) {
        var e_1, _a;
        /** @type {?} */
        var meta = ensureStoreMetadata(target.constructor);
        if (!Array.isArray(actions)) {
            actions = [actions];
        }
        try {
            for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                var action = actions_1_1.value;
                /** @type {?} */
                var type = action.type;
                if (!action.type) {
                    throw new Error("Action " + action.name + " is missing a static \"type\" property");
                }
                if (!meta.actions[type]) {
                    meta.actions[type] = [];
                }
                meta.actions[type].push({
                    fn: name,
                    options: options || {},
                    type: type
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');
/**
 * Error message
 * @ignore
 * @type {?}
 */
var stateNameErrorMessage = function (name) {
    return name + " is not a valid state name. It needs to be a valid object property name.";
};
/**
 * Decorates a class with ngxs state information.
 * @template T
 * @param {?} options
 * @return {?}
 */
function State(options) {
    return function (target) {
        /** @type {?} */
        var meta = ensureStoreMetadata(target);
        // Handle inheritance
        if (Object.getPrototypeOf(target).hasOwnProperty(META_KEY)) {
            /** @type {?} */
            var parentMeta = Object.getPrototypeOf(target)[META_KEY];
            meta.actions = __assign({}, meta.actions, parentMeta.actions);
        }
        meta.children = options.children;
        meta.defaults = options.defaults;
        meta.name = options.name;
        if (!options.name) {
            throw new Error("States must register a 'name' property");
        }
        if (!stateNameRegex.test(options.name)) {
            throw new Error(stateNameErrorMessage(options.name));
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorator for memoizing a state selector.
 * @param {?=} selectors
 * @return {?}
 */
function Selector(selectors) {
    return function (target, key, descriptor) {
        if (descriptor.value !== null) {
            /** @type {?} */
            var originalFn = descriptor.value;
            /** @type {?} */
            var memoizedFn_1 = createSelector(selectors, originalFn, { containerClass: target, selectorName: key });
            return {
                configurable: true,
                get: /**
                 * @return {?}
                 */
                function () {
                    return memoizedFn_1;
                }
            };
        }
        else {
            throw new Error('Selectors only work on methods');
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxsModule, Action, Store, State, Select, Actions, getSelectorMetadata, getStoreMetadata, ensureStoreMetadata, ensureSelectorMetadata, ofAction, ofActionDispatched, ofActionSuccessful, ofActionCanceled, ofActionErrored, Selector, getActionTypeFromInstance, actionMatcher, createSelector, NGXS_PLUGINS, StateStream, setValue, getValue, InitState, UpdateState, InternalActions as g, OrderedSubject as f, SelectFactory as e, InternalDispatchedActionResults as n, InternalDispatcher as o, StateContextFactory as p, StateFactory as m, InternalStateOperations as q, NgxsFeatureModule as b, NgxsRootModule as a, ROOT_OPTIONS as d, ngxsConfigFactory as c, PluginManager as r, FEATURE_STATE_TOKEN as i, META_KEY as j, NgxsConfig as l, ROOT_STATE_TOKEN as h, SELECTOR_META_KEY as k };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4cy1zdG9yZS5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQG5neHMvc3RvcmUvc3JjL3N5bWJvbHMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9pbnRlcm5hbHMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy91dGlscy91dGlscy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL29wZXJhdG9ycy9vZi1hY3Rpb24udHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9vcGVyYXRvcnMvem9uZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2FjdGlvbnMtc3RyZWFtLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvY29tcG9zZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLXN0cmVhbS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3BsdWdpbi1tYW5hZ2VyLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvaW50ZXJuYWwvZGlzcGF0Y2hlci50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3V0aWxzL2ZyZWV6ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnkudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1mYWN0b3J5LnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvbWVtb2l6ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3V0aWxzL3NlbGVjdG9yLXV0aWxzLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvc3RvcmUudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9kZWNvcmF0b3JzL3NlbGVjdC50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2FjdGlvbnMvYWN0aW9ucy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL21vZHVsZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2RlY29yYXRvcnMvYWN0aW9uLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvZGVjb3JhdG9ycy9zdGF0ZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2RlY29yYXRvcnMvc2VsZWN0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFJPT1RfU1RBVEVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48YW55PignUk9PVF9TVEFURV9UT0tFTicpO1xyXG5leHBvcnQgY29uc3QgRkVBVFVSRV9TVEFURV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KCdGRUFUVVJFX1NUQVRFX1RPS0VOJyk7XHJcbmV4cG9ydCBjb25zdCBNRVRBX0tFWSA9ICdOR1hTX01FVEEnO1xyXG5leHBvcnQgY29uc3QgU0VMRUNUT1JfTUVUQV9LRVkgPSAnTkdYU19TRUxFQ1RPUl9NRVRBJztcclxuXHJcbmV4cG9ydCBjb25zdCBOR1hTX1BMVUdJTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05HWFNfUExVR0lOUycpO1xyXG5leHBvcnQgdHlwZSBOZ3hzUGx1Z2luQ29uc3RydWN0b3IgPSBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBOZ3hzUGx1Z2luO1xyXG5leHBvcnQgdHlwZSBOZ3hzUGx1Z2luRm4gPSAoc3RhdGU6IGFueSwgbXV0YXRpb246IGFueSwgbmV4dDogTmd4c05leHRQbHVnaW5GbikgPT4gYW55O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBOR1hTIGNvbmZpZyBzZXR0aW5ncy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZ3hzQ29uZmlnIHtcclxuICAvKipcclxuICAgKiBSdW4gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gVGhpcyB3aWxsIGFkZCBhZGRpdGlvbmFsIGRlYnVnZ2luZyBmZWF0dXJlczpcclxuICAgKiAtIE9iamVjdC5mcmVlemUgb24gdGhlIHN0YXRlIGFuZCBhY3Rpb25zIHRvIGd1YXJhbnRlZSBpbW11dGFiaWxpdHlcclxuICAgKiAoZGVmYXVsdDogZmFsc2UpXHJcbiAgICovXHJcbiAgZGV2ZWxvcG1lbnRNb2RlOiBib29sZWFuO1xyXG4gIGNvbXBhdGliaWxpdHk6IHtcclxuICAgIC8qKlxyXG4gICAgICogU3VwcG9ydCBhIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cclxuICAgICAqIFRoaXMgd2lsbCBjaXJ1bXZlbnQgc29tZSBvcHRpbWlzYXRpb25zIHRoYXQgdmlvbGF0ZSBhIHN0cmljdCBDU1AgdGhyb3VnaCB0aGUgdXNlIG9mIGBuZXcgRnVuY3Rpb24oLi4uKWAuXHJcbiAgICAgKiAoZGVmYXVsdDogZmFsc2UpXHJcbiAgICAgKi9cclxuICAgIHN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeTogYm9vbGVhbjtcclxuICB9O1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY29tcGF0aWJpbGl0eSA9IHtcclxuICAgICAgc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5OiBmYWxzZVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBjb250ZXh0IHByb3ZpZGVkIHRvIHRoZSBhY3Rpb25zIGluIHRoZSBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVDb250ZXh0PFQ+IHtcclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAgICovXHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldFN0YXRlKHZhbDogVCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGNoIHRoZSBleGlzdGluZyBzdGF0ZSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgKi9cclxuICBwYXRjaFN0YXRlKHZhbDogUGFydGlhbDxUPik7XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoIGEgbmV3IGFjdGlvbiBhbmQgcmV0dXJuIHRoZSBkaXNwYXRjaGVkIG9ic2VydmFibGUuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzTmV4dFBsdWdpbkZuID0gKHN0YXRlOiBhbnksIG11dGF0aW9uOiBhbnkpID0+IGFueTtcclxuXHJcbi8qKlxyXG4gKiBQbHVnaW4gaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNQbHVnaW4ge1xyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSB0aGUgc3RhdGUvYWN0aW9uIGJlZm9yZSBpdHMgc3VibWl0dGVkIHRvIHRoZSBzdGF0ZSBoYW5kbGVycy5cclxuICAgKi9cclxuICBoYW5kbGUoc3RhdGU6IGFueSwgYWN0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pOiBhbnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIHRoYXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBzdG9yZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmVPcHRpb25zPFQ+IHtcclxuICAvKipcclxuICAgKiBOYW1lIG9mIHRoZSBzdGF0ZS4gUmVxdWlyZWQuXHJcbiAgICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgdGhlIHN0YXRlLiBJZiBub3QgcHJvdmlkZWQsIHVzZXMgZW1wdHkgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGRlZmF1bHRzPzogVDtcclxuXHJcbiAgLyoqXHJcbiAgICogU3ViIHN0YXRlcyBmb3IgdGhlIGdpdmVuIHN0YXRlLlxyXG4gICAqL1xyXG4gIGNoaWxkcmVuPzogYW55W107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBY3Rpb25zIHRoYXQgY2FuIGJlIHByb3ZpZGVkIGluIGEgYWN0aW9uIGRlY29yYXRvci5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uT3B0aW9ucyB7XHJcbiAgLyoqXHJcbiAgICogQ2FuY2VsIHRoZSBwcmV2aW91cyB1bmNvbXBsZXRlZCBvYnNlcnZhYmxlKHMpLlxyXG4gICAqL1xyXG4gIGNhbmNlbFVuY29tcGxldGVkPzogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIE9uIGluaXQgaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE5neHNPbkluaXQge1xyXG4gIG5neHNPbkluaXQoY3R4PzogU3RhdGVDb250ZXh0PGFueT4pOiB2b2lkIHwgYW55O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzTGlmZUN5Y2xlID0gUGFydGlhbDxOZ3hzT25Jbml0PjtcclxuIiwiaW1wb3J0IHsgTUVUQV9LRVksIEFjdGlvbk9wdGlvbnMsIFNFTEVDVE9SX01FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0S2V5TWFwPFQ+IHtcclxuICBba2V5OiBzdHJpbmddOiBUO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ2xhc3Mge1xyXG4gIFtNRVRBX0tFWV0/OiBNZXRhRGF0YU1vZGVsO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTdGF0ZUtleUdyYXBoID0gT2JqZWN0S2V5TWFwPHN0cmluZ1tdPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uSGFuZGxlck1ldGFEYXRhIHtcclxuICBmbjogc3RyaW5nO1xyXG4gIG9wdGlvbnM6IEFjdGlvbk9wdGlvbnM7XHJcbiAgdHlwZTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlT3BlcmF0aW9uczxUPiB7XHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuICBzZXRTdGF0ZSh2YWw6IFQpO1xyXG4gIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXRhRGF0YU1vZGVsIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgYWN0aW9uczogT2JqZWN0S2V5TWFwPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIHBhdGg6IHN0cmluZztcclxuICBzZWxlY3RGcm9tQXBwU3RhdGU6IFNlbGVjdEZyb21TdGF0ZTtcclxuICBjaGlsZHJlbjogU3RhdGVDbGFzc1tdO1xyXG4gIGluc3RhbmNlOiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNlbGVjdEZyb21TdGF0ZSA9IChzdGF0ZTogYW55KSA9PiBhbnk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgc2VsZWN0RnJvbUFwcFN0YXRlOiBTZWxlY3RGcm9tU3RhdGU7XHJcbiAgb3JpZ2luYWxGbjogRnVuY3Rpb247XHJcbiAgY29udGFpbmVyQ2xhc3M6IGFueTtcclxuICBzZWxlY3Rvck5hbWU6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXBwZWRTdG9yZSB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGFjdGlvbnM6IE9iamVjdEtleU1hcDxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBpbnN0YW5jZTogYW55O1xyXG4gIGRlcHRoOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBjbGFzcyBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0KTogTWV0YURhdGFNb2RlbCB7XHJcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoTUVUQV9LRVkpKSB7XHJcbiAgICBjb25zdCBkZWZhdWx0TWV0YWRhdGE6IE1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgIGFjdGlvbnM6IHt9LFxyXG4gICAgICBkZWZhdWx0czoge30sXHJcbiAgICAgIHBhdGg6IG51bGwsXHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICBpbnN0YW5jZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBNRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuICByZXR1cm4gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtZXRhZGF0YSBhdHRhY2hlZCB0byB0aGUgY2xhc3MgaWYgaXQgZXhpc3RzLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQpOiBNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W01FVEFfS0VZXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZXMgbWV0YWRhdGEgaXMgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGFuZCByZXR1cm5zIGl0LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQpOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KFNFTEVDVE9SX01FVEFfS0VZKSkge1xyXG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgb3JpZ2luYWxGbjogbnVsbCxcclxuICAgICAgY29udGFpbmVyQ2xhc3M6IG51bGwsXHJcbiAgICAgIHNlbGVjdG9yTmFtZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBTRUxFQ1RPUl9NRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W1NFTEVDVE9SX01FVEFfS0VZXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCBhcyBmYXN0IGFzIHRoZSBgZmFzdFByb3BHZXR0ZXJgIGJ1dCBpcyBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgY29tcGxpYW50LlxyXG4gKiBTZWUgcGVyZiBoaXQ6IGh0dHBzOi8vanNwZXJmLmNvbS9mYXN0LXZhbHVlLWdldHRlci1naXZlbi1wYXRoLzFcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGxpYW50UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xyXG4gIGNvbnN0IGNvcHlPZlBhdGhzID0gWy4uLnBhdGhzXTtcclxuICByZXR1cm4gb2JqID0+IGNvcHlPZlBhdGhzLnJlZHVjZSgoYWNjOiBhbnksIHBhcnQ6IHN0cmluZykgPT4gYWNjICYmIGFjY1twYXJ0XSwgb2JqKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW46XHJcbiAqIC0gcGx1Y2sgKE9ic2VydmFibGUgb3BlcmF0b3IpXHJcbiAqIC0gbWVtb2l6ZVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBmYXN0UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xyXG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aHM7XHJcbiAgbGV0IHNlZyA9ICdzdG9yZS4nICsgc2VnbWVudHNbMF07XHJcbiAgbGV0IGkgPSAwO1xyXG4gIGNvbnN0IGwgPSBzZWdtZW50cy5sZW5ndGg7XHJcblxyXG4gIGxldCBleHByID0gc2VnO1xyXG4gIHdoaWxlICgrK2kgPCBsKSB7XHJcbiAgICBleHByID0gZXhwciArICcgJiYgJyArIChzZWcgPSBzZWcgKyAnLicgKyBzZWdtZW50c1tpXSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbignc3RvcmUnLCAncmV0dXJuICcgKyBleHByICsgJzsnKTtcclxuXHJcbiAgcmV0dXJuIDwoeDogYW55KSA9PiBhbnk+Zm47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdLCBjb25maWc6IE5neHNDb25maWcpIHtcclxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5jb21wYXRpYmlsaXR5ICYmIGNvbmZpZy5jb21wYXRpYmlsaXR5LnN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeSkge1xyXG4gICAgcmV0dXJuIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZmFzdFByb3BHZXR0ZXIocGF0aHMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHN0YXRlcywgaXQgd2lsbCByZXR1cm4gYSBvYmplY3QgZ3JhcGguIEV4YW1wbGU6XHJcbiAqICAgIGNvbnN0IHN0YXRlcyA9IFtcclxuICogICAgICBDYXJ0LFxyXG4gKiAgICAgIENhcnRTYXZlZCxcclxuICogICAgICBDYXJ0U2F2ZWRJdGVtc1xyXG4gKiAgICBdXHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR3JhcGgoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW10pOiBTdGF0ZUtleUdyYXBoIHtcclxuICBjb25zdCBmaW5kTmFtZSA9IChzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc2VzLmZpbmQoZyA9PiBnID09PSBzdGF0ZUNsYXNzKTtcclxuICAgIGlmICghbWV0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlIG5vdCBmb3VuZDogJHtzdGF0ZUNsYXNzfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbWV0YVtNRVRBX0tFWV0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZXMgbXVzdCBiZSBkZWNvcmF0ZWQgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3InKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWV0YVtNRVRBX0tFWV0ubmFtZTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc3RhdGVDbGFzc2VzLnJlZHVjZTxTdGF0ZUtleUdyYXBoPigocmVzdWx0OiBTdGF0ZUtleUdyYXBoLCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICBpZiAoIXN0YXRlQ2xhc3NbTUVUQV9LRVldKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGVzIG11c3QgYmUgZGVjb3JhdGVkIHdpdGggQFN0YXRlKCkgZGVjb3JhdG9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBuYW1lLCBjaGlsZHJlbiB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcbiAgICByZXN1bHRbbmFtZV0gPSAoY2hpbGRyZW4gfHwgW10pLm1hcChmaW5kTmFtZSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgc3RhdGVzIGFycmF5LCByZXR1cm5zIG9iamVjdCBncmFwaFxyXG4gKiByZXR1cm5pbmcgdGhlIG5hbWUgYW5kIHN0YXRlIG1ldGFkYXRhLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IHsgbWV0YWRhdGEgfVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVUb1N0YXRlKHN0YXRlczogU3RhdGVDbGFzc1tdKTogT2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3M+IHtcclxuICByZXR1cm4gc3RhdGVzLnJlZHVjZTxPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz4+KChyZXN1bHQ6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiwgc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgaWYgKCFzdGF0ZUNsYXNzW01FVEFfS0VZXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlcyBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXTtcclxuICAgIHJlc3VsdFttZXRhLm5hbWVdID0gc3RhdGVDbGFzcztcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSwge30pO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBvYmplY3QgcmVsYXRpb25zaGlwIGdyYXBoIHdpbGwgcmV0dXJuIHRoZSBmdWxsIHBhdGhcclxuICogZm9yIHRoZSBjaGlsZCBpdGVtcy4gRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogd291bGQgcmV0dXJuOlxyXG4gKlxyXG4gKiAgY29uc3QgciA9IHtcclxuICogICAgY2FydDogJ2NhcnQnLFxyXG4gKiAgICBzYXZlZDogJ2NhcnQuc2F2ZWQnLFxyXG4gKiAgICBpdGVtczogJ2NhcnQuc2F2ZWQuaXRlbXMnXHJcbiAqICB9O1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZ1bGxQYXJlbnRQYXRoKG9iajogU3RhdGVLZXlHcmFwaCwgbmV3T2JqOiBPYmplY3RLZXlNYXA8c3RyaW5nPiA9IHt9KTogT2JqZWN0S2V5TWFwPHN0cmluZz4ge1xyXG4gIGNvbnN0IHZpc2l0ID0gKGNoaWxkOiBTdGF0ZUtleUdyYXBoLCBrZXlUb0ZpbmQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZCkge1xyXG4gICAgICBpZiAoY2hpbGQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjaGlsZFtrZXldLmluZGV4T2Yoa2V5VG9GaW5kKSA+PSAwKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQoY2hpbGQsIGtleSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQob2JqLCBrZXkpO1xyXG4gICAgICBuZXdPYmpba2V5XSA9IHBhcmVudCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXdPYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIG9iamVjdCBncmFwaCwgaXQgd2lsbCByZXR1cm4gdGhlIGl0ZW1zIHRvcG9sb2dpY2FsbHkgc29ydGVkIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHJlc3VsdHMgPSBbXHJcbiAqICAgICdpdGVtcycsXHJcbiAqICAgICdzYXZlZCcsXHJcbiAqICAgICdjYXJ0J1xyXG4gKiAgXTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvcG9sb2dpY2FsU29ydChncmFwaDogU3RhdGVLZXlHcmFwaCk6IHN0cmluZ1tdIHtcclxuICBjb25zdCBzb3J0ZWQ6IHN0cmluZ1tdID0gW107XHJcbiAgY29uc3QgdmlzaXRlZDogT2JqZWN0S2V5TWFwPGJvb2xlYW4+ID0ge307XHJcblxyXG4gIGNvbnN0IHZpc2l0ID0gKG5hbWU6IHN0cmluZywgYW5jZXN0b3JzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYW5jZXN0b3JzKSkge1xyXG4gICAgICBhbmNlc3RvcnMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBhbmNlc3RvcnMucHVzaChuYW1lKTtcclxuICAgIHZpc2l0ZWRbbmFtZV0gPSB0cnVlO1xyXG5cclxuICAgIGdyYXBoW25hbWVdLmZvckVhY2goKGRlcDogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGlmIChhbmNlc3RvcnMuaW5kZXhPZihkZXApID49IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENpcmN1bGFyIGRlcGVuZGVuY3kgJyR7ZGVwfScgaXMgcmVxdWlyZWQgYnkgJyR7bmFtZX0nOiAke2FuY2VzdG9ycy5qb2luKCcgLT4gJyl9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2aXNpdGVkW2RlcF0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZpc2l0KGRlcCwgYW5jZXN0b3JzLnNsaWNlKDApKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChzb3J0ZWQuaW5kZXhPZihuYW1lKSA8IDApIHtcclxuICAgICAgc29ydGVkLnB1c2gobmFtZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgT2JqZWN0LmtleXMoZ3JhcGgpLmZvckVhY2goayA9PiB2aXNpdChrKSk7XHJcblxyXG4gIHJldHVybiBzb3J0ZWQucmV2ZXJzZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgb2JqZWN0IG9yIG5vdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xyXG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0eXBlIGZyb20gYW4gYWN0aW9uIGluc3RhbmNlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb246IGFueSk6IHN0cmluZyB7XHJcbiAgaWYgKGFjdGlvbi5jb25zdHJ1Y3RvciAmJiBhY3Rpb24uY29uc3RydWN0b3IudHlwZSkge1xyXG4gICAgcmV0dXJuIGFjdGlvbi5jb25zdHJ1Y3Rvci50eXBlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFjdGlvbi50eXBlO1xyXG59XHJcblxyXG4vKipcclxuICogTWF0Y2hlcyBhIGFjdGlvblxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWN0aW9uTWF0Y2hlcihhY3Rpb24xOiBhbnkpIHtcclxuICBjb25zdCB0eXBlMSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uMSk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbihhY3Rpb24yOiBhbnkpIHtcclxuICAgIHJldHVybiB0eXBlMSA9PT0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24yKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICBzZXRWYWx1ZSh7IGZvbzogeyBiYXI6IHsgZWF0OiBmYWxzZSB9IH0gfSxcclxuICogICAgICAnZm9vLmJhci5lYXQnLCB0cnVlKSAvLz0+IHsgZm9vOiB7IGJhcjogeyBlYXQ6IHRydWUgfSB9IH1cclxuICpcclxuICogV2hpbGUgaXQgdHJhdmVyc2VzIGl0IGFsc28gY3JlYXRlcyBuZXcgb2JqZWN0cyBmcm9tIHRvcCBkb3duLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2V0VmFsdWUgPSAob2JqOiBhbnksIHByb3A6IHN0cmluZywgdmFsOiBhbnkpID0+IHtcclxuICBvYmogPSB7IC4uLm9iaiB9O1xyXG5cclxuICBjb25zdCBzcGxpdCA9IHByb3Auc3BsaXQoJy4nKTtcclxuICBjb25zdCBsYXN0SW5kZXggPSBzcGxpdC5sZW5ndGggLSAxO1xyXG5cclxuICBzcGxpdC5yZWR1Y2UoKGFjYywgcGFydCwgaW5kZXgpID0+IHtcclxuICAgIGlmIChpbmRleCA9PT0gbGFzdEluZGV4KSB7XHJcbiAgICAgIGFjY1twYXJ0XSA9IHZhbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFjY1twYXJ0XSA9IEFycmF5LmlzQXJyYXkoYWNjW3BhcnRdKSA/IFsuLi5hY2NbcGFydF1dIDogeyAuLi5hY2NbcGFydF0gfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWNjICYmIGFjY1twYXJ0XTtcclxuICB9LCBvYmopO1xyXG5cclxuICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0VmFsdWUgPSAob2JqOiBhbnksIHByb3A6IHN0cmluZykgPT5cclxuICBwcm9wLnNwbGl0KCcuJykucmVkdWNlKChhY2M6IGFueSwgcGFydDogc3RyaW5nKSA9PiBhY2MgJiYgYWNjW3BhcnRdLCBvYmopO1xyXG4iLCJpbXBvcnQgeyBPcGVyYXRvckZ1bmN0aW9uLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCwgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBBY3Rpb25Db250ZXh0LCBBY3Rpb25TdGF0dXMgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb248VD4oYWxsb3dlZFR5cGUpOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD47XHJcbmV4cG9ydCBmdW5jdGlvbiBvZkFjdGlvbjxUPiguLi5hbGxvd2VkVHlwZXMpOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD47XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IGJlZW4gZGlzcGF0Y2hlZCBhcyB3ZWxsIGFzIGFjdGlvbnMgdGhhdCBoYXZlIGNvbXBsZXRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMpO1xyXG59XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgT05MWSBncmFiIGFjdGlvbnMgdGhhdCBoYXZlIGp1c3QgYmVlbiBkaXNwYXRjaGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25EaXNwYXRjaGVkKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMsIEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ4SlMgb3BlcmF0b3IgZm9yIHNlbGVjdGluZyBvdXQgc3BlY2lmaWMgYWN0aW9ucy5cclxuICpcclxuICogVGhpcyB3aWxsIE9OTFkgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IGJlZW4gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uU3VjY2Vzc2Z1bCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSeEpTIG9wZXJhdG9yIGZvciBzZWxlY3Rpbmcgb3V0IHNwZWNpZmljIGFjdGlvbnMuXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCBPTkxZIGdyYWIgYWN0aW9ucyB0aGF0IGhhdmUganVzdCBiZWVuIGNhbmNlbGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25DYW5jZWxlZCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgT05MWSBncmFiIGFjdGlvbnMgdGhhdCBoYXZlIGp1c3QgdGhyb3duIGFuIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb25FcnJvcmVkKC4uLmFsbG93ZWRUeXBlczogYW55W10pIHtcclxuICByZXR1cm4gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXMsIEFjdGlvblN0YXR1cy5FcnJvcmVkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb2ZBY3Rpb25PcGVyYXRvcihhbGxvd2VkVHlwZXM6IGFueVtdLCBzdGF0dXM/OiBBY3Rpb25TdGF0dXMpIHtcclxuICBjb25zdCBhbGxvd2VkTWFwID0gY3JlYXRlQWxsb3dlZE1hcChhbGxvd2VkVHlwZXMpO1xyXG4gIHJldHVybiBmdW5jdGlvbihvOiBPYnNlcnZhYmxlPGFueT4pIHtcclxuICAgIHJldHVybiBvLnBpcGUoXHJcbiAgICAgIGZpbHRlclN0YXR1cyhhbGxvd2VkTWFwLCBzdGF0dXMpLFxyXG4gICAgICBtYXBBY3Rpb24oKVxyXG4gICAgKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJTdGF0dXMoYWxsb3dlZFR5cGVzOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSwgc3RhdHVzPzogQWN0aW9uU3RhdHVzKSB7XHJcbiAgcmV0dXJuIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCBhY3Rpb25UeXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShjdHguYWN0aW9uKTtcclxuICAgIGNvbnN0IHR5cGUgPSBhbGxvd2VkVHlwZXNbYWN0aW9uVHlwZV07XHJcbiAgICByZXR1cm4gc3RhdHVzID8gdHlwZSAmJiBjdHguc3RhdHVzID09PSBzdGF0dXMgOiB0eXBlO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBBY3Rpb24oKSB7XHJcbiAgcmV0dXJuIG1hcCgoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguYWN0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQWxsb3dlZE1hcCh0eXBlczogYW55W10pOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSB7XHJcbiAgcmV0dXJuIHR5cGVzLnJlZHVjZSgoYWNjOiBhbnksIGtsYXNzOiBhbnkpID0+IHtcclxuICAgIGFjY1tnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGtsYXNzKV0gPSB0cnVlO1xyXG4gICAgcmV0dXJuIGFjYztcclxuICB9LCB7fSk7XHJcbn1cclxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vKipcclxuICogT3BlcmF0b3IgdG8gcnVuIHRoZSBgc3Vic2NyaWJlYCBpbiBhIEFuZ3VsYXIgem9uZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnRlclpvbmU8VD4oem9uZTogTmdab25lKSB7XHJcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHtcclxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgoc2luazogT2JzZXJ2ZXI8VD4pID0+IHtcclxuICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoe1xyXG4gICAgICAgIG5leHQoeCkge1xyXG4gICAgICAgICAgem9uZS5ydW4oKCkgPT4gc2luay5uZXh0KHgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yKGUpIHtcclxuICAgICAgICAgIHpvbmUucnVuKCgpID0+IHNpbmsuZXJyb3IoZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGxldGUoKSB7XHJcbiAgICAgICAgICB6b25lLnJ1bigoKSA9PiBzaW5rLmNvbXBsZXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgeyBlbnRlclpvbmUgfSBmcm9tICcuL29wZXJhdG9ycy96b25lJztcclxuXHJcbi8qKlxyXG4gKiBTdGF0dXMgb2YgYSBkaXNwYXRjaGVkIGFjdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVudW0gQWN0aW9uU3RhdHVzIHtcclxuICBEaXNwYXRjaGVkID0gJ0RJU1BBVENIRUQnLFxyXG4gIFN1Y2Nlc3NmdWwgPSAnU1VDQ0VTU0ZVTCcsXHJcbiAgQ2FuY2VsZWQgPSAnQ0FOQ0VMRUQnLFxyXG4gIEVycm9yZWQgPSAnRVJST1JFRCdcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25Db250ZXh0IHtcclxuICBzdGF0dXM6IEFjdGlvblN0YXR1cztcclxuICBhY3Rpb246IGFueTtcclxuICBlcnJvcj86IEVycm9yO1xyXG59XHJcblxyXG4vKipcclxuICogQ3VzdG9tIFN1YmplY3QgdGhhdCBlbnN1cmVzIHRoYXQgc3Vic2NyaWJlcnMgYXJlIG5vdGlmaWVkIG9mIHZhbHVlcyBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFycml2ZWQuXHJcbiAqIEEgc3RhbmRhcmQgU3ViamVjdCBkb2VzIG5vdCBoYXZlIHRoaXMgZ3VhcmFudGVlLlxyXG4gKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGZvbGxvd2luZyBjb2RlOlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqICAgY29uc3Qgc3ViamVjdCA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcclxuICAgICBzdWJqZWN0LnN1YnNjcmliZSh2YWx1ZSA9PiB7XHJcbiAgICAgICBpZiAodmFsdWUgPT09ICdzdGFydCcpIHN1YmplY3QubmV4dCgnZW5kJyk7XHJcbiAgICAgfSk7XHJcbiAgICAgc3ViamVjdC5zdWJzY3JpYmUodmFsdWUgPT4geyB9KTtcclxuICAgICBzdWJqZWN0Lm5leHQoJ3N0YXJ0Jyk7XHJcbiAqIGBgYFxyXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIHN0YW5kYXJkIGBTdWJqZWN0PFQ+YCB0aGUgc2Vjb25kIHN1YnNjcmliZXIgd291bGQgcmVjaWV2ZSBgZW5kYCBhbmQgdGhlbiBgc3RhcnRgLlxyXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIGBPcmRlcmVkU3ViamVjdDxUPmAgdGhlIHNlY29uZCBzdWJzY3JpYmVyIHdvdWxkIHJlY2lldmUgYHN0YXJ0YCBhbmQgdGhlbiBgZW5kYC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBPcmRlcmVkU3ViamVjdDxUPiBleHRlbmRzIFN1YmplY3Q8VD4ge1xyXG4gIHByaXZhdGUgX2l0ZW1RdWV1ZTogVFtdID0gW107XHJcbiAgcHJpdmF0ZSBfYnVzeVB1c2hpbmdOZXh0ID0gZmFsc2U7XHJcblxyXG4gIG5leHQodmFsdWU/OiBUKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fYnVzeVB1c2hpbmdOZXh0KSB7XHJcbiAgICAgIHRoaXMuX2l0ZW1RdWV1ZS51bnNoaWZ0KHZhbHVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYnVzeVB1c2hpbmdOZXh0ID0gdHJ1ZTtcclxuICAgIHN1cGVyLm5leHQodmFsdWUpO1xyXG4gICAgd2hpbGUgKHRoaXMuX2l0ZW1RdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHRoaXMuX2l0ZW1RdWV1ZS5wb3AoKTtcclxuICAgICAgc3VwZXIubmV4dChuZXh0VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYnVzeVB1c2hpbmdOZXh0ID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgQWN0aW9uIHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgYW55dGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEludGVybmFsQWN0aW9ucyBleHRlbmRzIE9yZGVyZWRTdWJqZWN0PEFjdGlvbkNvbnRleHQ+IHt9XHJcblxyXG4vKipcclxuICogQWN0aW9uIHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgYW55dGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cclxuICpcclxuICogWW91IGNhbiBsaXN0ZW4gdG8gdGhpcyBpbiBzZXJ2aWNlcyB0byByZWFjdCB3aXRob3V0IHN0b3Jlcy5cclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEFjdGlvbnMgZXh0ZW5kcyBPYnNlcnZhYmxlPGFueT4ge1xyXG4gIGNvbnN0cnVjdG9yKGFjdGlvbnMkOiBJbnRlcm5hbEFjdGlvbnMsIG5nWm9uZTogTmdab25lKSB7XHJcbiAgICBzdXBlcihvYnNlcnZlciA9PiB7XHJcbiAgICAgIGFjdGlvbnMkXHJcbiAgICAgICAgLnBpcGUoZW50ZXJab25lKG5nWm9uZSkpXHJcbiAgICAgICAgLnN1YnNjcmliZShyZXMgPT4gb2JzZXJ2ZXIubmV4dChyZXMpLCBlcnIgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSwgKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvbXBvc2VzIGEgYXJyYXkgb2YgZnVuY3Rpb25zIGZyb20gbGVmdCB0byByaWdodC4gRXhhbXBsZTpcclxuICpcclxuICogICAgICBjb21wb3NlKFtmbiwgZmluYWxdKShzdGF0ZSwgYWN0aW9uKTtcclxuICpcclxuICogdGhlbiB0aGUgZnVuY3MgaGF2ZSBhIHNpZ25hdHVyZSBsaWtlOlxyXG4gKlxyXG4gKiAgICAgIGZ1bmN0aW9uIGZuIChzdGF0ZSwgYWN0aW9uLCBuZXh0KSB7XHJcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKCdoZXJlJywgc3RhdGUsIGFjdGlvbiwgbmV4dCk7XHJcbiAqICAgICAgICAgIHJldHVybiBuZXh0KHN0YXRlLCBhY3Rpb24pO1xyXG4gKiAgICAgIH1cclxuICpcclxuICogICAgICBmdW5jdGlvbiBmaW5hbCAoc3RhdGUsIGFjdGlvbikge1xyXG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnaGVyZScsIHN0YXRlLCBhY3Rpb24pO1xyXG4gKiAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAqICAgICAgfVxyXG4gKlxyXG4gKiB0aGUgbGFzdCBmdW5jdGlvbiBzaG91bGQgbm90IGNhbGwgYG5leHRgLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29tcG9zZSA9IGZ1bmNzID0+ICguLi5hcmdzKSA9PiB7XHJcbiAgY29uc3QgY3VyciA9IGZ1bmNzLnNoaWZ0KCk7XHJcbiAgcmV0dXJuIGN1cnIoLi4uYXJncywgKC4uLm5leHRBcmdzKSA9PiBjb21wb3NlKGZ1bmNzKSguLi5uZXh0QXJncykpO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuLyoqXHJcbiAqIEJlaGF2aW9yU3ViamVjdCBvZiB0aGUgZW50aXJlIHN0YXRlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZVN0cmVhbSBleHRlbmRzIEJlaGF2aW9yU3ViamVjdDxhbnk+IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKHt9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFNraXBTZWxmLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmd4c1BsdWdpbkZuLCBOR1hTX1BMVUdJTlMsIE5neHNQbHVnaW4gfSBmcm9tICcuL3N5bWJvbHMnO1xyXG5cclxuLyoqXHJcbiAqIFBsdWdpbiBtYW5hZ2VyIGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFBsdWdpbk1hbmFnZXIge1xyXG4gIHBsdWdpbnM6IE5neHNQbHVnaW5GbltdID0gW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBTa2lwU2VsZigpXHJcbiAgICBwcml2YXRlIF9wYXJlbnRNYW5hZ2VyOiBQbHVnaW5NYW5hZ2VyLFxyXG4gICAgQEluamVjdChOR1hTX1BMVUdJTlMpXHJcbiAgICBAT3B0aW9uYWwoKVxyXG4gICAgcHJpdmF0ZSBfcGx1Z2luczogTmd4c1BsdWdpbltdXHJcbiAgKSB7XHJcbiAgICB0aGlzLnJlZ2lzdGVyKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlZ2lzdGVyKCkge1xyXG4gICAgaWYgKCF0aGlzLl9wbHVnaW5zKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zLm1hcChwbHVnaW4gPT4ge1xyXG4gICAgICBpZiAocGx1Z2luLmhhbmRsZSkge1xyXG4gICAgICAgIHJldHVybiBwbHVnaW4uaGFuZGxlLmJpbmQocGx1Z2luKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcGx1Z2luO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fcGFyZW50TWFuYWdlcikge1xyXG4gICAgICB0aGlzLl9wYXJlbnRNYW5hZ2VyLnBsdWdpbnMucHVzaCguLi50aGlzLnBsdWdpbnMpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBFcnJvckhhbmRsZXIsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgZm9ya0pvaW4sIGVtcHR5LCBTdWJqZWN0LCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHNoYXJlUmVwbGF5LCBmaWx0ZXIsIGV4aGF1c3RNYXAsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBjb21wb3NlIH0gZnJvbSAnLi4vdXRpbHMvY29tcG9zZSc7XHJcbmltcG9ydCB7IEludGVybmFsQWN0aW9ucywgQWN0aW9uU3RhdHVzLCBBY3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBTdGF0ZVN0cmVhbSB9IGZyb20gJy4vc3RhdGUtc3RyZWFtJztcclxuaW1wb3J0IHsgUGx1Z2luTWFuYWdlciB9IGZyb20gJy4uL3BsdWdpbi1tYW5hZ2VyJztcclxuaW1wb3J0IHsgZW50ZXJab25lIH0gZnJvbSAnLi4vb3BlcmF0b3JzL3pvbmUnO1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIEFjdGlvbiByZXN1bHQgc3RyZWFtIHRoYXQgaXMgZW1pdHRlZCB3aGVuIGFuIGFjdGlvbiBpcyBjb21wbGV0ZWQuXHJcbiAqIFRoaXMgaXMgdXNlZCBhcyBhIG1ldGhvZCBvZiByZXR1cm5pbmcgdGhlIGFjdGlvbiByZXN1bHQgdG8gdGhlIGRpc3BhdGNoZXJcclxuICogZm9yIHRoZSBvYnNlcnZhYmxlIHJldHVybmVkIGJ5IHRoZSBkaXNwYXRjaCguLi4pIGNhbGwuXHJcbiAqIFRoZSBkaXNwYXRjaGVyIHRoZW4gYXN5bmNocm9ub3VzbHkgcHVzaGVzIHRoZSByZXN1bHQgZnJvbSB0aGlzIHN0cmVhbSBvbnRvIHRoZSBtYWluIGFjdGlvbiBzdHJlYW0gYXMgYSByZXN1bHQuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIGV4dGVuZHMgU3ViamVjdDxBY3Rpb25Db250ZXh0PiB7fVxyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxEaXNwYXRjaGVyIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX2Vycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uUmVzdWx0czogSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgIHByaXZhdGUgX3BsdWdpbk1hbmFnZXI6IFBsdWdpbk1hbmFnZXIsXHJcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogU3RhdGVTdHJlYW0sXHJcbiAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZVxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGF0Y2hlcyBldmVudChzKS5cclxuICAgKi9cclxuICBkaXNwYXRjaChldmVudDogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3QgcmVzdWx0OiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcclxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oZXZlbnQubWFwKGEgPT4gdGhpcy5kaXNwYXRjaFNpbmdsZShhKSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoU2luZ2xlKGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmVzdWx0LnN1YnNjcmliZSh7XHJcbiAgICAgIGVycm9yOiBlcnJvciA9PiB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuX2Vycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvcikpXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0LnBpcGUoZW50ZXJab25lKHRoaXMuX25nWm9uZSkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkaXNwYXRjaFNpbmdsZShhY3Rpb246IGFueSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpO1xyXG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbk1hbmFnZXIucGx1Z2lucztcclxuXHJcbiAgICByZXR1cm4gKGNvbXBvc2UoW1xyXG4gICAgICAuLi5wbHVnaW5zLFxyXG4gICAgICAobmV4dFN0YXRlLCBuZXh0QWN0aW9uKSA9PiB7XHJcbiAgICAgICAgaWYgKG5leHRTdGF0ZSAhPT0gcHJldlN0YXRlKSB7XHJcbiAgICAgICAgICB0aGlzLl9zdGF0ZVN0cmVhbS5uZXh0KG5leHRTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjdGlvblJlc3VsdCQgPSB0aGlzLmdldEFjdGlvblJlc3VsdFN0cmVhbShuZXh0QWN0aW9uKTtcclxuICAgICAgICBhY3Rpb25SZXN1bHQkLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9ucy5uZXh0KGN0eCkpO1xyXG4gICAgICAgIHRoaXMuX2FjdGlvbnMubmV4dCh7IGFjdGlvbjogbmV4dEFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEaXNwYXRjaE9ic2VydmFibGUoYWN0aW9uUmVzdWx0JCk7XHJcbiAgICAgIH1cclxuICAgIF0pKHByZXZTdGF0ZSwgYWN0aW9uKSBhcyBPYnNlcnZhYmxlPGFueT4pLnBpcGUoc2hhcmVSZXBsYXkoKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEFjdGlvblJlc3VsdFN0cmVhbShhY3Rpb246IGFueSk6IE9ic2VydmFibGU8QWN0aW9uQ29udGV4dD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGlvblJlc3VsdHMucGlwZShcclxuICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5hY3Rpb24gPT09IGFjdGlvbiAmJiBjdHguc3RhdHVzICE9PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXHJcbiAgICAgIHRha2UoMSksXHJcbiAgICAgIHNoYXJlUmVwbGF5KClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZURpc3BhdGNoT2JzZXJ2YWJsZShhY3Rpb25SZXN1bHQkOiBPYnNlcnZhYmxlPEFjdGlvbkNvbnRleHQ+KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiBhY3Rpb25SZXN1bHQkXHJcbiAgICAgIC5waXBlKFxyXG4gICAgICAgIGV4aGF1c3RNYXAoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4ge1xyXG4gICAgICAgICAgc3dpdGNoIChjdHguc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWw6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG9mKHRoaXMuX3N0YXRlU3RyZWFtLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICBjYXNlIEFjdGlvblN0YXR1cy5FcnJvcmVkOlxyXG4gICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGN0eC5lcnJvcik7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgKVxyXG4gICAgICAucGlwZShzaGFyZVJlcGxheSgpKTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIE9iamVjdCBmcmVlemUgY29kZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNkZi9kZWVwLWZyZWV6ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRlZXBGcmVlemUgPSBvID0+IHtcclxuICBPYmplY3QuZnJlZXplKG8pO1xyXG5cclxuICBjb25zdCBvSXNGdW5jdGlvbiA9IHR5cGVvZiBvID09PSAnZnVuY3Rpb24nO1xyXG4gIGNvbnN0IGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcclxuICAgIGlmIChcclxuICAgICAgaGFzT3duUHJvcC5jYWxsKG8sIHByb3ApICYmXHJcbiAgICAgIChvSXNGdW5jdGlvbiA/IHByb3AgIT09ICdjYWxsZXInICYmIHByb3AgIT09ICdjYWxsZWUnICYmIHByb3AgIT09ICdhcmd1bWVudHMnIDogdHJ1ZSkgJiZcclxuICAgICAgb1twcm9wXSAhPT0gbnVsbCAmJlxyXG4gICAgICAodHlwZW9mIG9bcHJvcF0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvW3Byb3BdID09PSAnZnVuY3Rpb24nKSAmJlxyXG4gICAgICAhT2JqZWN0LmlzRnJvemVuKG9bcHJvcF0pXHJcbiAgICApIHtcclxuICAgICAgZGVlcEZyZWV6ZShvW3Byb3BdKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG87XHJcbn07XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIGlzRGV2TW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVyIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IFN0YXRlU3RyZWFtIH0gZnJvbSAnLi9zdGF0ZS1zdHJlYW0nO1xyXG5pbXBvcnQgeyBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7IGRlZXBGcmVlemUgfSBmcm9tICcuLi91dGlscy9mcmVlemUnO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRlIENvbnRleHQgZmFjdG9yeSBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB7XHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc3RhdGVTdHJlYW06IFN0YXRlU3RyZWFtLCBwcml2YXRlIF9kaXNwYXRjaGVyOiBJbnRlcm5hbERpc3BhdGNoZXIsIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZykge1xyXG4gICAgdGhpcy52ZXJpZnlEZXZNb2RlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSByb290IHN0YXRlIG9wZXJhdG9ycy5cclxuICAgKi9cclxuICBnZXRSb290U3RhdGVPcGVyYXRpb25zKCk6IFN0YXRlT3BlcmF0aW9uczxhbnk+IHtcclxuICAgIGNvbnN0IHJvb3RTdGF0ZU9wZXJhdGlvbnMgPSB7XHJcbiAgICAgIGdldFN0YXRlOiAoKSA9PiB0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpLFxyXG4gICAgICBzZXRTdGF0ZTogbmV3U3RhdGUgPT4gdGhpcy5fc3RhdGVTdHJlYW0ubmV4dChuZXdTdGF0ZSksXHJcbiAgICAgIGRpc3BhdGNoOiBhY3Rpb25zID0+IHRoaXMuX2Rpc3BhdGNoZXIuZGlzcGF0Y2goYWN0aW9ucylcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5kZXZlbG9wbWVudE1vZGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlU3RhdGVBbmRBY3Rpb25zQXJlSW1tdXRhYmxlKHJvb3RTdGF0ZU9wZXJhdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb290U3RhdGVPcGVyYXRpb25zO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB2ZXJpZnlEZXZNb2RlKCkge1xyXG4gICAgY29uc3QgaXNOZ3hzRGV2TW9kZSA9IHRoaXMuX2NvbmZpZy5kZXZlbG9wbWVudE1vZGU7XHJcbiAgICBjb25zdCBpc05nRGV2TW9kZSA9IGlzRGV2TW9kZSgpO1xyXG4gICAgY29uc3QgaW5jb3JyZWN0UHJvZHVjdGlvbiA9ICFpc05nRGV2TW9kZSAmJiBpc05neHNEZXZNb2RlO1xyXG4gICAgY29uc3QgaW5jb3JyZWN0RGV2ZWxvcG1lbnQgPSBpc05nRGV2TW9kZSAmJiAhaXNOZ3hzRGV2TW9kZTtcclxuICAgIGNvbnN0IGV4YW1wbGUgPSAnTmd4c01vZHVsZS5mb3JSb290KHN0YXRlcywgeyBkZXZlbG9wbWVudE1vZGU6ICFlbnZpcm9ubWVudC5wcm9kdWN0aW9uIH0pJztcclxuXHJcbiAgICBpZiAoaW5jb3JyZWN0UHJvZHVjdGlvbikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgJ0FuZ3VsYXIgaXMgcnVubmluZyBpbiBwcm9kdWN0aW9uIG1vZGUgYnV0IE5HWFMgaXMgc3RpbGwgcnVubmluZyBpbiB0aGUgZGV2ZWxvcG1lbnQgbW9kZSFcXG4nLFxyXG4gICAgICAgICdQbGVhc2Ugc2V0IGRldmVsb3BtZW50TW9kZSB0byBmYWxzZSBvbiB0aGUgTmd4c01vZHVsZSBvcHRpb25zIHdoZW4gaW4gcHJvZHVjdGlvbiBtb2RlLlxcbicsXHJcbiAgICAgICAgZXhhbXBsZVxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIGlmIChpbmNvcnJlY3REZXZlbG9wbWVudCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgJ1JFQ09NTUVOREFUSU9OOiBTZXQgZGV2ZWxvcG1lbnRNb2RlIHRvIHRydWUgb24gdGhlIE5neHNNb2R1bGUgd2hlbiBBbmd1bGFyIGlzIHJ1bm5pbmcgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG4nLFxyXG4gICAgICAgIGV4YW1wbGVcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZW5zdXJlU3RhdGVBbmRBY3Rpb25zQXJlSW1tdXRhYmxlKHJvb3Q6IFN0YXRlT3BlcmF0aW9uczxhbnk+KTogU3RhdGVPcGVyYXRpb25zPGFueT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2V0U3RhdGU6ICgpID0+IHJvb3QuZ2V0U3RhdGUoKSxcclxuICAgICAgc2V0U3RhdGU6IHZhbHVlID0+IHtcclxuICAgICAgICBjb25zdCBmcm96ZW5WYWx1ZSA9IGRlZXBGcmVlemUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByb290LnNldFN0YXRlKGZyb3plblZhbHVlKTtcclxuICAgICAgfSxcclxuICAgICAgZGlzcGF0Y2g6IGFjdGlvbnMgPT4ge1xyXG4gICAgICAgIHJldHVybiByb290LmRpc3BhdGNoKGFjdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dCB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQgeyBNYXBwZWRTdG9yZSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IHNldFZhbHVlLCBnZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1vcGVyYXRpb25zJztcclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBDb250ZXh0IGZhY3RvcnkgY2xhc3NcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RhdGVDb250ZXh0RmFjdG9yeSB7XHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIHN0YXRlIGNvbnRleHRcclxuICAgKi9cclxuICBjcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGE6IE1hcHBlZFN0b3JlKTogU3RhdGVDb250ZXh0PGFueT4ge1xyXG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldFN0YXRlKCk6IGFueSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSByb290LmdldFN0YXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlKHN0YXRlLCBtZXRhZGF0YS5kZXB0aCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHBhdGNoU3RhdGUodmFsOiBhbnkpOiBhbnkge1xyXG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbCk7XHJcbiAgICAgICAgY29uc3QgaXNQcmltaXRpdmUgPSB0eXBlb2YgdmFsICE9PSAnb2JqZWN0JztcclxuXHJcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0Y2hpbmcgYXJyYXlzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRjaGluZyBwcmltaXRpdmVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHJvb3QuZ2V0U3RhdGUoKTtcclxuICAgICAgICBjb25zdCBsb2NhbCA9IGdldFZhbHVlKHN0YXRlLCBtZXRhZGF0YS5kZXB0aCk7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSB7IC4uLmxvY2FsIH07XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgayBpbiB2YWwpIHtcclxuICAgICAgICAgIGNsb25lW2tdID0gdmFsW2tdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBzZXRWYWx1ZShzdGF0ZSwgbWV0YWRhdGEuZGVwdGgsIGNsb25lKTtcclxuICAgICAgICByb290LnNldFN0YXRlKG5ld1N0YXRlKTtcclxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldFN0YXRlKHZhbDogYW55KTogYW55IHtcclxuICAgICAgICBsZXQgc3RhdGUgPSByb290LmdldFN0YXRlKCk7XHJcbiAgICAgICAgc3RhdGUgPSBzZXRWYWx1ZShzdGF0ZSwgbWV0YWRhdGEuZGVwdGgsIHZhbCk7XHJcbiAgICAgICAgcm9vdC5zZXRTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICB9LFxyXG4gICAgICBkaXNwYXRjaChhY3Rpb25zOiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIHJvb3QuZGlzcGF0Y2goYWN0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdG9yLCBJbmplY3RhYmxlLCBTa2lwU2VsZiwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIGZvcmtKb2luLCBmcm9tLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHNoYXJlUmVwbGF5LCB0YWtlVW50aWwsIG1hcCwgY2F0Y2hFcnJvciwgZmlsdGVyLCBtZXJnZU1hcCwgZGVmYXVsdElmRW1wdHkgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBNRVRBX0tFWSwgTmd4c0xpZmVDeWNsZSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQge1xyXG4gIHRvcG9sb2dpY2FsU29ydCxcclxuICBidWlsZEdyYXBoLFxyXG4gIGZpbmRGdWxsUGFyZW50UGF0aCxcclxuICBuYW1lVG9TdGF0ZSxcclxuICBwcm9wR2V0dGVyLFxyXG4gIGlzT2JqZWN0LFxyXG4gIFN0YXRlQ2xhc3MsXHJcbiAgTWFwcGVkU3RvcmVcclxufSBmcm9tICcuL2ludGVybmFscyc7XHJcbmltcG9ydCB7IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UsIHNldFZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBvZkFjdGlvbkRpc3BhdGNoZWQgfSBmcm9tICcuLi9vcGVyYXRvcnMvb2YtYWN0aW9uJztcclxuaW1wb3J0IHsgSW50ZXJuYWxBY3Rpb25zLCBBY3Rpb25TdGF0dXMsIEFjdGlvbkNvbnRleHQgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XHJcbmltcG9ydCB7IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMgfSBmcm9tICcuLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgU3RhdGVDb250ZXh0RmFjdG9yeSB9IGZyb20gJy4uL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XHJcblxyXG4vKipcclxuICogU3RhdGUgZmFjdG9yeSBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZUZhY3Rvcnkge1xyXG4gIGdldCBzdGF0ZXMoKTogTWFwcGVkU3RvcmVbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzIDogdGhpcy5fc3RhdGVzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc3RhdGVzOiBNYXBwZWRTdG9yZVtdID0gW107XHJcbiAgcHJpdmF0ZSBfY29ubmVjdGVkID0gZmFsc2U7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxyXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBOZ3hzQ29uZmlnLFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBTa2lwU2VsZigpXHJcbiAgICBwcml2YXRlIF9wYXJlbnRGYWN0b3J5OiBTdGF0ZUZhY3RvcnksXHJcbiAgICBwcml2YXRlIF9hY3Rpb25zOiBJbnRlcm5hbEFjdGlvbnMsXHJcbiAgICBwcml2YXRlIF9hY3Rpb25SZXN1bHRzOiBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzLFxyXG4gICAgcHJpdmF0ZSBfc3RhdGVDb250ZXh0RmFjdG9yeTogU3RhdGVDb250ZXh0RmFjdG9yeVxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgbmV3IHN0YXRlIHRvIHRoZSBnbG9iYWwgZGVmcy5cclxuICAgKi9cclxuICBhZGQob25lT3JNYW55U3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzIHwgU3RhdGVDbGFzc1tdKTogTWFwcGVkU3RvcmVbXSB7XHJcbiAgICBsZXQgc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW107XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob25lT3JNYW55U3RhdGVDbGFzc2VzKSkge1xyXG4gICAgICBzdGF0ZUNsYXNzZXMgPSBbb25lT3JNYW55U3RhdGVDbGFzc2VzXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXRlQ2xhc3NlcyA9IG9uZU9yTWFueVN0YXRlQ2xhc3NlcztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdGF0ZUdyYXBoID0gYnVpbGRHcmFwaChzdGF0ZUNsYXNzZXMpO1xyXG4gICAgY29uc3Qgc29ydGVkU3RhdGVzID0gdG9wb2xvZ2ljYWxTb3J0KHN0YXRlR3JhcGgpO1xyXG4gICAgY29uc3QgZGVwdGhzID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xyXG4gICAgY29uc3QgbmFtZUdyYXBoID0gbmFtZVRvU3RhdGUoc3RhdGVDbGFzc2VzKTtcclxuICAgIGNvbnN0IG1hcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3J0ZWRTdGF0ZXMpIHtcclxuICAgICAgY29uc3Qgc3RhdGVDbGFzcyA9IG5hbWVHcmFwaFtuYW1lXTtcclxuXHJcbiAgICAgIGlmICghc3RhdGVDbGFzc1tNRVRBX0tFWV0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlcyBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvcicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkZXB0aCA9IGRlcHRoc1tuYW1lXTtcclxuICAgICAgY29uc3QgeyBhY3Rpb25zIH0gPSBzdGF0ZUNsYXNzW01FVEFfS0VZXTtcclxuICAgICAgbGV0IHsgZGVmYXVsdHMgfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldO1xyXG5cclxuICAgICAgc3RhdGVDbGFzc1tNRVRBX0tFWV0ucGF0aCA9IGRlcHRoO1xyXG4gICAgICBzdGF0ZUNsYXNzW01FVEFfS0VZXS5zZWxlY3RGcm9tQXBwU3RhdGUgPSBwcm9wR2V0dGVyKGRlcHRoLnNwbGl0KCcuJyksIHRoaXMuX2NvbmZpZyk7XHJcblxyXG4gICAgICAvLyBlbnN1cmUgb3VyIHN0b3JlIGhhc24ndCBhbHJlYWR5IGJlZW4gYWRkZWRcclxuICAgICAgLy8gYnV0IGRvbnQgdGhyb3cgc2luY2UgaXQgY291bGQgYmUgbGF6eVxyXG4gICAgICAvLyBsb2FkZWQgZnJvbSBkaWZmZXJlbnQgcGF0aHNcclxuICAgICAgY29uc3QgaGFzID0gdGhpcy5zdGF0ZXMuZmluZChzID0+IHMubmFtZSA9PT0gbmFtZSk7XHJcbiAgICAgIGlmICghaGFzKSB7XHJcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBpbnN0YW5jZSBvZiBkZWZhdWx0c1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRzKSkge1xyXG4gICAgICAgICAgZGVmYXVsdHMgPSBbLi4uZGVmYXVsdHNdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGVmYXVsdHMpKSB7XHJcbiAgICAgICAgICBkZWZhdWx0cyA9IHsgLi4uZGVmYXVsdHMgfTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGRlZmF1bHRzID0ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX2luamVjdG9yLmdldChzdGF0ZUNsYXNzKTtcclxuXHJcbiAgICAgICAgbWFwcGVkU3RvcmVzLnB1c2goe1xyXG4gICAgICAgICAgYWN0aW9ucyxcclxuICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgZGVmYXVsdHMsXHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgZGVwdGhcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhdGVzLnB1c2goLi4ubWFwcGVkU3RvcmVzKTtcclxuXHJcbiAgICByZXR1cm4gbWFwcGVkU3RvcmVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc2V0IG9mIHN0YXRlcyB0byB0aGUgc3RvcmUgYW5kIHJldHVybiB0aGUgZGVmYXVsc3RzXHJcbiAgICovXHJcbiAgYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVDbGFzc2VzOiBhbnlbXSk6IHsgZGVmYXVsdHM6IGFueTsgc3RhdGVzOiBNYXBwZWRTdG9yZVtdIH0ge1xyXG4gICAgaWYgKHN0YXRlQ2xhc3Nlcykge1xyXG4gICAgICBjb25zdCBzdGF0ZXMgPSB0aGlzLmFkZChzdGF0ZUNsYXNzZXMpO1xyXG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN0YXRlcy5yZWR1Y2UoXHJcbiAgICAgICAgKHJlc3VsdDogYW55LCBtZXRhOiBNYXBwZWRTdG9yZSkgPT4gc2V0VmFsdWUocmVzdWx0LCBtZXRhLmRlcHRoLCBtZXRhLmRlZmF1bHRzKSxcclxuICAgICAgICB7fVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIHRoZSBhY3Rpb25zIHRvIHRoZSBoYW5kbGVyc1xyXG4gICAqL1xyXG4gIGNvbm5lY3RBY3Rpb25IYW5kbGVycygpIHtcclxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHJldHVybjtcclxuICAgIHRoaXMuX2FjdGlvbnNcclxuICAgICAgLnBpcGUoXHJcbiAgICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5zdGF0dXMgPT09IEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKSxcclxuICAgICAgICBtZXJnZU1hcCgoeyBhY3Rpb24gfSkgPT5cclxuICAgICAgICAgIHRoaXMuaW52b2tlQWN0aW9ucyh0aGlzLl9hY3Rpb25zLCBhY3Rpb24pLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoKSA9PiA8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCB9KSxcclxuICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkNhbmNlbGVkIH0pLFxyXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVycm9yID0+IG9mKDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5FcnJvcmVkLCBlcnJvciB9KSlcclxuICAgICAgICAgIClcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgICAgLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9uUmVzdWx0cy5uZXh0KGN0eCkpO1xyXG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZSB0aGUgaW5pdCBmdW5jdGlvbiBvbiB0aGUgc3RhdGVzLlxyXG4gICAqL1xyXG4gIGludm9rZUluaXQoc3RhdGVNZXRhZGF0YXM6IE1hcHBlZFN0b3JlW10pIHtcclxuICAgIGZvciAoY29uc3QgbWV0YWRhdGEgb2Ygc3RhdGVNZXRhZGF0YXMpIHtcclxuICAgICAgY29uc3QgaW5zdGFuY2U6IE5neHNMaWZlQ3ljbGUgPSBtZXRhZGF0YS5pbnN0YW5jZTtcclxuXHJcbiAgICAgIGlmIChpbnN0YW5jZS5uZ3hzT25Jbml0KSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gICAgICAgIGluc3RhbmNlLm5neHNPbkluaXQoc3RhdGVDb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlIGFjdGlvbnMgb24gdGhlIHN0YXRlcy5cclxuICAgKi9cclxuICBpbnZva2VBY3Rpb25zKGFjdGlvbnMkOiBJbnRlcm5hbEFjdGlvbnMsIGFjdGlvbikge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgbWV0YWRhdGEgb2YgdGhpcy5zdGF0ZXMpIHtcclxuICAgICAgY29uc3QgdHlwZSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uKTtcclxuICAgICAgY29uc3QgYWN0aW9uTWV0YXMgPSBtZXRhZGF0YS5hY3Rpb25zW3R5cGVdO1xyXG5cclxuICAgICAgaWYgKGFjdGlvbk1ldGFzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25NZXRhIG9mIGFjdGlvbk1ldGFzKSB7XHJcbiAgICAgICAgICBjb25zdCBzdGF0ZUNvbnRleHQgPSB0aGlzLmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGEuaW5zdGFuY2VbYWN0aW9uTWV0YS5mbl0oc3RhdGVDb250ZXh0LCBhY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBmcm9tKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUoXHJcbiAgICAgICAgICAgICAgICBhY3Rpb25NZXRhLm9wdGlvbnMuY2FuY2VsVW5jb21wbGV0ZWRcclxuICAgICAgICAgICAgICAgICAgPyB0YWtlVW50aWwoYWN0aW9ucyQucGlwZShvZkFjdGlvbkRpc3BhdGNoZWQoYWN0aW9uKSkpXHJcbiAgICAgICAgICAgICAgICAgIDogbWFwKHIgPT4gcilcclxuICAgICAgICAgICAgICApOyAvLyBtYXAgYWN0cyBsaWtlIGEgbm9vcFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IG9mKHt9KS5waXBlKHNoYXJlUmVwbGF5KCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRocm93RXJyb3IoZSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgcmVzdWx0cy5wdXNoKG9mKHt9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvcmtKb2luKHJlc3VsdHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBzdGF0ZSBjb250ZXh0XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGE6IE1hcHBlZFN0b3JlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVDb250ZXh0RmFjdG9yeS5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gIH1cclxufVxyXG4iLCJmdW5jdGlvbiBkZWZhdWx0RXF1YWxpdHlDaGVjayhhLCBiKSB7XHJcbiAgcmV0dXJuIGEgPT09IGI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKGVxdWFsaXR5Q2hlY2ssIHByZXYsIG5leHQpIHtcclxuICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cclxuICBjb25zdCBsZW5ndGggPSBwcmV2Lmxlbmd0aDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZW1vaXplIGEgZnVuY3Rpb24gb24gaXRzIGxhc3QgaW5wdXRzIG9ubHkuXHJcbiAqIE9yaW5naW5hbGx5IGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3Jlc2VsZWN0L2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCBlcXVhbGl0eUNoZWNrID0gZGVmYXVsdEVxdWFsaXR5Q2hlY2spIHtcclxuICBsZXQgbGFzdEFyZ3MgPSBudWxsO1xyXG4gIGxldCBsYXN0UmVzdWx0ID0gbnVsbDtcclxuICAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcclxuICByZXR1cm4gPCguLi5hcmdzKSA9PiBhbnk+ZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XHJcbiAgICBpZiAoIWFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKGVxdWFsaXR5Q2hlY2ssIGxhc3RBcmdzLCBhcmd1bWVudHMpKSB7XHJcbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXHJcbiAgICAgIGxhc3RSZXN1bHQgPSBmdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IFNlbGVjdEZyb21TdGF0ZSwgZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSwgZ2V0U2VsZWN0b3JNZXRhZGF0YSwgZ2V0U3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuLi91dGlscy9tZW1vaXplJztcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBzZWxlY3RvclxyXG4gKiBAcGFyYW0gc2VsZWN0b3JzIFRoZSBzZWxlY3RvcnMgdG8gdXNlIHRvIGNyZWF0ZSB0aGUgYXJndW1lbnRzIG9mIHRoaXMgZnVuY3Rpb25cclxuICogQHBhcmFtIG9yaWdpbmFsRm4gVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGJlaW5nIG1hZGUgaW50byBhIHNlbGVjdG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoXHJcbiAgc2VsZWN0b3JzOiBhbnlbXSxcclxuICBvcmlnaW5hbEZuOiBhbnksXHJcbiAgY3JlYXRpb25NZXRhZGF0YT86IHsgY29udGFpbmVyQ2xhc3M6IGFueTsgc2VsZWN0b3JOYW1lOiBzdHJpbmcgfVxyXG4pIHtcclxuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiB3cmFwcGVkU2VsZWN0b3JGbiguLi5hcmdzKSB7XHJcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9yaWdpbmFsRm4oLi4uYXJncyk7XHJcbiAgICBpZiAocmV0dXJuVmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICBjb25zdCBpbm5lck1lbW9pemVkRm4gPSBtZW1vaXplLmFwcGx5KG51bGwsIFtyZXR1cm5WYWx1ZV0pO1xyXG4gICAgICByZXR1cm4gaW5uZXJNZW1vaXplZEZuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gIH07XHJcbiAgY29uc3QgbWVtb2l6ZWRGbiA9IG1lbW9pemUod3JhcHBlZEZuKTtcclxuICBjb25zdCBjb250YWluZXJDbGFzcyA9IGNyZWF0aW9uTWV0YWRhdGEgJiYgY3JlYXRpb25NZXRhZGF0YS5jb250YWluZXJDbGFzcztcclxuXHJcbiAgY29uc3QgZm4gPSBzdGF0ZSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgY29uc3Qgc2VsZWN0b3JzVG9BcHBseSA9IFtdO1xyXG5cclxuICAgIGlmIChjb250YWluZXJDbGFzcykge1xyXG4gICAgICAvLyBJZiB3ZSBhcmUgb24gYSBzdGF0ZSBjbGFzcywgYWRkIGl0IGFzIHRoZSBmaXJzdCBzZWxlY3RvciBwYXJhbWV0ZXJcclxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBnZXRTdG9yZU1ldGFkYXRhKGNvbnRhaW5lckNsYXNzKTtcclxuICAgICAgaWYgKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKGNvbnRhaW5lckNsYXNzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNlbGVjdG9ycykge1xyXG4gICAgICBzZWxlY3RvcnNUb0FwcGx5LnB1c2goLi4uc2VsZWN0b3JzKTtcclxuICAgIH1cclxuICAgIC8vIERldGVybWluZSBhcmd1bWVudHMgZnJvbSB0aGUgYXBwIHN0YXRlIHVzaW5nIHRoZSBzZWxlY3RvcnNcclxuICAgIGlmIChzZWxlY3RvcnNUb0FwcGx5KSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaCguLi5zZWxlY3RvcnNUb0FwcGx5Lm1hcChhID0+IGdldFNlbGVjdG9yRm4oYSkoc3RhdGUpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdGhlIGxhbWJkYSB0cmllcyB0byBhY2Nlc3MgYSBzb21ldGhpbmcgb24gdGhlXHJcbiAgICAvLyBzdGF0ZSB0aGF0IGRvZXNuJ3QgZXhpc3QsIGl0IHdpbGwgdGhyb3cgYSBUeXBlRXJyb3IuXHJcbiAgICAvLyBzaW5jZSB0aGlzIGlzIHF1aXRlIHVzdWFsIGJlaGF2aW91ciwgd2Ugc2ltcGx5IHJldHVybiB1bmRlZmluZWQgaWYgc28uXHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gbWVtb2l6ZWRGbiguLi5yZXN1bHRzKTtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXg7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgc2VsZWN0b3JNZXRhRGF0YSA9IGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEobWVtb2l6ZWRGbik7XHJcbiAgc2VsZWN0b3JNZXRhRGF0YS5vcmlnaW5hbEZuID0gb3JpZ2luYWxGbjtcclxuICBzZWxlY3Rvck1ldGFEYXRhLnNlbGVjdEZyb21BcHBTdGF0ZSA9IGZuO1xyXG4gIGlmIChjcmVhdGlvbk1ldGFkYXRhKSB7XHJcbiAgICBzZWxlY3Rvck1ldGFEYXRhLmNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YS5jb250YWluZXJDbGFzcztcclxuICAgIHNlbGVjdG9yTWV0YURhdGEuc2VsZWN0b3JOYW1lID0gY3JlYXRpb25NZXRhZGF0YS5zZWxlY3Rvck5hbWU7XHJcbiAgfVxyXG4gIHJldHVybiBtZW1vaXplZEZuO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB0byBiZSB1c2VkIHRvIGdldCB0aGUgc2VsZWN0ZWQgc2xpY2UgZnJvbSB0aGUgYXBwIHN0YXRlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvckZuKHNlbGVjdG9yOiBhbnkpOiBTZWxlY3RGcm9tU3RhdGUge1xyXG4gIGNvbnN0IG1ldGFkYXRhID0gZ2V0U2VsZWN0b3JNZXRhZGF0YShzZWxlY3RvcikgfHwgZ2V0U3RvcmVNZXRhZGF0YShzZWxlY3Rvcik7XHJcbiAgcmV0dXJuIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5zZWxlY3RGcm9tQXBwU3RhdGUpIHx8IHNlbGVjdG9yO1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGNhdGNoRXJyb3IsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBnZXRTZWxlY3RvckZuIH0gZnJvbSAnLi91dGlscy9zZWxlY3Rvci11dGlscyc7XHJcbmltcG9ydCB7IEludGVybmFsU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1vcGVyYXRpb25zJztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IGVudGVyWm9uZSB9IGZyb20gJy4vb3BlcmF0b3JzL3pvbmUnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RvcmUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXHJcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogU3RhdGVTdHJlYW0sXHJcbiAgICBwcml2YXRlIF9pbnRlcm5hbFN0YXRlT3BlcmF0aW9uczogSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnNcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgZXZlbnQocykuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goZXZlbnQ6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuZGlzcGF0Y2goZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0cyBhIHNsaWNlIG9mIGRhdGEgZnJvbSB0aGUgc3RvcmUuXHJcbiAgICovXHJcbiAgc2VsZWN0PFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IE9ic2VydmFibGU8VD47XHJcbiAgc2VsZWN0KHNlbGVjdG9yOiBzdHJpbmcgfCBhbnkpOiBPYnNlcnZhYmxlPGFueT47XHJcbiAgc2VsZWN0KHNlbGVjdG9yOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3Qgc2VsZWN0b3JGbiA9IGdldFNlbGVjdG9yRm4oc2VsZWN0b3IpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlU3RyZWFtLnBpcGUoXHJcbiAgICAgIG1hcChzZWxlY3RvckZuKSxcclxuICAgICAgY2F0Y2hFcnJvcihlcnIgPT4ge1xyXG4gICAgICAgIC8vIGlmIGVycm9yIGlzIFR5cGVFcnJvciB3ZSBzd2FsbG93IGl0IHRvIHByZXZlbnQgdXN1YWwgZXJyb3JzIHdpdGggcHJvcGVydHkgYWNjZXNzXHJcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXRocm93IG90aGVyIGVycm9yc1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgICAgfSksXHJcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICAgIGVudGVyWm9uZSh0aGlzLl9uZ1pvbmUpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0IG9uZSBzbGljZSBvZiBkYXRhIGZyb20gdGhlIHN0b3JlLlxyXG4gICAqL1xyXG4gIHNlbGVjdE9uY2U8VD4oc2VsZWN0b3I6IChzdGF0ZTogYW55LCAuLi5zdGF0ZXM6IGFueVtdKSA9PiBUKTogT2JzZXJ2YWJsZTxUPjtcclxuICBzZWxlY3RPbmNlKHNlbGVjdG9yOiBzdHJpbmcgfCBhbnkpOiBPYnNlcnZhYmxlPGFueT47XHJcbiAgc2VsZWN0T25jZShzZWxlY3RvcjogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiB0aGlzLnNlbGVjdChzZWxlY3RvcikucGlwZSh0YWtlKDEpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdCBhIHNuYXBzaG90IGZyb20gdGhlIHN0YXRlLlxyXG4gICAqL1xyXG4gIHNlbGVjdFNuYXBzaG90PFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IFQ7XHJcbiAgc2VsZWN0U25hcHNob3Qoc2VsZWN0b3I6IHN0cmluZyB8IGFueSk6IGFueTtcclxuICBzZWxlY3RTbmFwc2hvdChzZWxlY3RvcjogYW55KTogYW55IHtcclxuICAgIGNvbnN0IHNlbGVjdG9yRm4gPSBnZXRTZWxlY3RvckZuKHNlbGVjdG9yKTtcclxuICAgIHJldHVybiBzZWxlY3RvckZuKHRoaXMuX3N0YXRlU3RyZWFtLmdldFZhbHVlKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gc3Vic2NyaWJlIHRvIHRoZSByb290IG9mIHRoZSBzdGF0ZVxyXG4gICAqL1xyXG4gIHN1YnNjcmliZShmbj86IGFueSk6IFN1YnNjcmlwdGlvbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVTdHJlYW0ucGlwZShlbnRlclpvbmUodGhpcy5fbmdab25lKSkuc3Vic2NyaWJlKGZuKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgcmF3IHZhbHVlIG9mIHRoZSBzdGF0ZS5cclxuICAgKi9cclxuICBzbmFwc2hvdCgpOiBhbnkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKS5nZXRTdGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZS4gVGhpcyBtZXRob2QgaXMgdXNlZnVsXHJcbiAgICogZm9yIHBsdWdpbidzIHdobyBuZWVkIHRvIG1vZGlmeSB0aGUgc3RhdGUgZGlyZWN0bHkgb3IgdW5pdCB0ZXN0aW5nLlxyXG4gICAqL1xyXG4gIHJlc2V0KHN0YXRlOiBhbnkpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuc2V0U3RhdGUoc3RhdGUpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJy4uL3N0b3JlJztcclxuaW1wb3J0IHsgcHJvcEdldHRlciB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IE1FVEFfS0VZLCBOZ3hzQ29uZmlnIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcblxyXG4vKipcclxuICogQWxsb3dzIHRoZSBzZWxlY3QgZGVjb3JhdG9yIHRvIGdldCBhY2Nlc3MgdG8gdGhlIERJIHN0b3JlLlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3RGYWN0b3J5IHtcclxuICBzdGF0aWMgc3RvcmU6IFN0b3JlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gIHN0YXRpYyBjb25maWc6IE5neHNDb25maWcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgY29uc3RydWN0b3Ioc3RvcmU6IFN0b3JlLCBjb25maWc6IE5neHNDb25maWcpIHtcclxuICAgIFNlbGVjdEZhY3Rvcnkuc3RvcmUgPSBzdG9yZTtcclxuICAgIFNlbGVjdEZhY3RvcnkuY29uZmlnID0gY29uZmlnO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29yYXRvciBmb3Igc2VsZWN0aW5nIGEgc2xpY2Ugb2Ygc3RhdGUgZnJvbSB0aGUgc3RvcmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0KHNlbGVjdG9yT3JGZWF0dXJlPywgLi4ucGF0aHM6IHN0cmluZ1tdKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55LCBuYW1lOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHNlbGVjdG9yRm5OYW1lID0gJ19fJyArIG5hbWUgKyAnX19zZWxlY3Rvcic7XHJcblxyXG4gICAgaWYgKCFzZWxlY3Rvck9yRmVhdHVyZSkge1xyXG4gICAgICAvLyBpZiBmb28kID0+IG1ha2UgaXQganVzdCBmb29cclxuICAgICAgc2VsZWN0b3JPckZlYXR1cmUgPSBuYW1lLmxhc3RJbmRleE9mKCckJykgPT09IG5hbWUubGVuZ3RoIC0gMSA/IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSkgOiBuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNyZWF0ZVNlbGVjdCA9IGZuID0+IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSBTZWxlY3RGYWN0b3J5LnN0b3JlO1xyXG5cclxuICAgICAgaWYgKCFzdG9yZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VsZWN0RmFjdG9yeSBub3QgY29ubmVjdGVkIHRvIHN0b3JlIScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RvcmUuc2VsZWN0KGZuKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY3JlYXRlU2VsZWN0b3IgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IFNlbGVjdEZhY3RvcnkuY29uZmlnO1xyXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yT3JGZWF0dXJlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IHByb3BzQXJyYXkgPSBwYXRocy5sZW5ndGggPyBbc2VsZWN0b3JPckZlYXR1cmUsIC4uLnBhdGhzXSA6IHNlbGVjdG9yT3JGZWF0dXJlLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9wR2V0dGVyKHByb3BzQXJyYXksIGNvbmZpZyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3JPckZlYXR1cmVbTUVUQV9LRVldICYmIHNlbGVjdG9yT3JGZWF0dXJlW01FVEFfS0VZXS5wYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BHZXR0ZXIoc2VsZWN0b3JPckZlYXR1cmVbTUVUQV9LRVldLnBhdGguc3BsaXQoJy4nKSwgY29uZmlnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc2VsZWN0b3JPckZlYXR1cmU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHRhcmdldFtzZWxlY3RvckZuTmFtZV0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBAU2VsZWN0IGRlY29yYXRvciBhbmQgYSAnICsgc2VsZWN0b3JGbk5hbWUgKyAnIHByb3BlcnR5LicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkZWxldGUgdGFyZ2V0W25hbWVdKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHNlbGVjdG9yRm5OYW1lLCB7XHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpc1tzZWxlY3RvckZuTmFtZV0gfHwgKHRoaXNbc2VsZWN0b3JGbk5hbWVdID0gY3JlYXRlU2VsZWN0LmFwcGx5KHRoaXMsIFtjcmVhdGVTZWxlY3RvcigpXSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4iLCIvKipcclxuICogSW5pdCBhY3Rpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbml0U3RhdGUge1xyXG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuICAgIC8vIE5PVEU6IE5vdCBuZWNlc3NhcnkgdG8gZGVjbGFyZSB0aGUgdHlwZSBpbiB0aGlzIHdheSBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmd4cy9zdG9yZS9wdWxsLzY0NCNpc3N1ZWNvbW1lbnQtNDM2MDAzMTM4XHJcbiAgICByZXR1cm4gJ0BASU5JVCc7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIGFjdGlvblxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFVwZGF0ZVN0YXRlIHtcclxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcbiAgICAvLyBOT1RFOiBOb3QgbmVjZXNzYXJ5IHRvIGRlY2xhcmUgdGhlIHR5cGUgaW4gdGhpcyB3YXkgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25neHMvc3RvcmUvcHVsbC82NDQjaXNzdWVjb21tZW50LTQzNjAwMzEzOFxyXG4gICAgcmV0dXJuICdAQFVQREFURV9TVEFURSc7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IE5nTW9kdWxlLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBPcHRpb25hbCwgSW5qZWN0LCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgUk9PVF9TVEFURV9UT0tFTiwgRkVBVFVSRV9TVEFURV9UT0tFTiwgTmd4c0NvbmZpZyB9IGZyb20gJy4vc3ltYm9scyc7XHJcbmltcG9ydCB7IFN0YXRlRmFjdG9yeSB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtZmFjdG9yeSc7XHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XHJcbmltcG9ydCB7IEFjdGlvbnMsIEludGVybmFsQWN0aW9ucyB9IGZyb20gJy4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZXIsIEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMgfSBmcm9tICcuL2ludGVybmFsL2Rpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnLi9zdG9yZSc7XHJcbmltcG9ydCB7IFNlbGVjdEZhY3RvcnkgfSBmcm9tICcuL2RlY29yYXRvcnMvc2VsZWN0JztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IFBsdWdpbk1hbmFnZXIgfSBmcm9tICcuL3BsdWdpbi1tYW5hZ2VyJztcclxuaW1wb3J0IHsgSW5pdFN0YXRlLCBVcGRhdGVTdGF0ZSB9IGZyb20gJy4vYWN0aW9ucy9hY3Rpb25zJztcclxuXHJcbi8qKlxyXG4gKiBSb290IG1vZHVsZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ATmdNb2R1bGUoKVxyXG5leHBvcnQgY2xhc3MgTmd4c1Jvb3RNb2R1bGUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgZmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxyXG4gICAgc3RvcmU6IFN0b3JlLFxyXG4gICAgc2VsZWN0OiBTZWxlY3RGYWN0b3J5LFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoUk9PVF9TVEFURV9UT0tFTilcclxuICAgIHN0YXRlczogYW55W11cclxuICApIHtcclxuICAgIC8vIGFkZCBzdG9yZXMgdG8gdGhlIHN0YXRlIGdyYXBoIGFuZCByZXR1cm4gdGhlaXIgZGVmYXVsdHNcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBmYWN0b3J5LmFkZEFuZFJldHVybkRlZmF1bHRzKHN0YXRlcyk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGVPcGVyYXRpb25zID0gaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpO1xyXG4gICAgaWYgKHJlc3VsdHMpIHtcclxuICAgICAgLy8gZ2V0IG91ciBjdXJyZW50IHN0cmVhbVxyXG4gICAgICBjb25zdCBjdXIgPSBzdGF0ZU9wZXJhdGlvbnMuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIC8vIHNldCB0aGUgc3RhdGUgdG8gdGhlIGN1cnJlbnQgKyBuZXdcclxuICAgICAgc3RhdGVPcGVyYXRpb25zLnNldFN0YXRlKHsgLi4uY3VyLCAuLi5yZXN1bHRzLmRlZmF1bHRzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbm5lY3Qgb3VyIGFjdGlvbnMgc3RyZWFtXHJcbiAgICBmYWN0b3J5LmNvbm5lY3RBY3Rpb25IYW5kbGVycygpO1xyXG5cclxuICAgIC8vIGRpc3BhdGNoIHRoZSBpbml0IGFjdGlvbiBhbmQgaW52b2tlIGluaXQgZnVuY3Rpb24gYWZ0ZXJcclxuICAgIHN0YXRlT3BlcmF0aW9ucy5kaXNwYXRjaChuZXcgSW5pdFN0YXRlKCkpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgIGlmIChyZXN1bHRzKSB7XHJcbiAgICAgICAgZmFjdG9yeS5pbnZva2VJbml0KHJlc3VsdHMuc3RhdGVzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmVhdHVyZSBtb2R1bGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQE5nTW9kdWxlKHt9KVxyXG5leHBvcnQgY2xhc3MgTmd4c0ZlYXR1cmVNb2R1bGUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgc3RvcmU6IFN0b3JlLFxyXG4gICAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxyXG4gICAgZmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoRkVBVFVSRV9TVEFURV9UT0tFTilcclxuICAgIHN0YXRlczogYW55W11bXVxyXG4gICkge1xyXG4gICAgLy8gU2luY2UgRkVBVFVSRV9TVEFURV9UT0tFTiBpcyBhIG11bHRpIHRva2VuLCB3ZSBuZWVkIHRvXHJcbiAgICAvLyBmbGF0dGVuIGl0IFtbRmVhdHVyZTFTdGF0ZSwgRmVhdHVyZTJTdGF0ZV0sIFtGZWF0dXJlM1N0YXRlXV1cclxuICAgIGNvbnN0IGZsYXR0ZW5lZFN0YXRlcyA9IChbXSBhcyBhbnlbXSkuY29uY2F0KC4uLnN0YXRlcyk7XHJcblxyXG4gICAgLy8gYWRkIHN0b3JlcyB0byB0aGUgc3RhdGUgZ3JhcGggYW5kIHJldHVybiB0aGVpciBkZWZhdWx0c1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGZhY3RvcnkuYWRkQW5kUmV0dXJuRGVmYXVsdHMoZmxhdHRlbmVkU3RhdGVzKTtcclxuXHJcbiAgICBjb25zdCBzdGF0ZU9wZXJhdGlvbnMgPSBpbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCk7XHJcbiAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAvLyBnZXQgb3VyIGN1cnJlbnQgc3RyZWFtXHJcbiAgICAgIGNvbnN0IGN1ciA9IHN0YXRlT3BlcmF0aW9ucy5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgLy8gc2V0IHRoZSBzdGF0ZSB0byB0aGUgY3VycmVudCArIG5ld1xyXG4gICAgICBzdGF0ZU9wZXJhdGlvbnMuc2V0U3RhdGUoeyAuLi5jdXIsIC4uLnJlc3VsdHMuZGVmYXVsdHMgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGVPcGVyYXRpb25zLmRpc3BhdGNoKG5ldyBVcGRhdGVTdGF0ZSgpKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAgIGZhY3RvcnkuaW52b2tlSW5pdChyZXN1bHRzLnN0YXRlcyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTW9kdWxlT3B0aW9ucyA9IFBhcnRpYWw8Tmd4c0NvbmZpZz47XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbmd4c0NvbmZpZ0ZhY3Rvcnkob3B0aW9uczogTW9kdWxlT3B0aW9ucyk6IE5neHNDb25maWcge1xyXG4gIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24obmV3IE5neHNDb25maWcoKSwgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIGNvbmZpZztcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFJPT1RfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxNb2R1bGVPcHRpb25zPignUk9PVF9PUFRJT05TJyk7XHJcblxyXG4vKipcclxuICogTmd4cyBNb2R1bGVcclxuICovXHJcbkBOZ01vZHVsZSh7fSlcclxuZXhwb3J0IGNsYXNzIE5neHNNb2R1bGUge1xyXG4gIC8qKlxyXG4gICAqIFJvb3QgbW9kdWxlIGZhY3RvcnlcclxuICAgKi9cclxuICBzdGF0aWMgZm9yUm9vdChzdGF0ZXM6IGFueVtdID0gW10sIG9wdGlvbnM6IE1vZHVsZU9wdGlvbnMgPSB7fSk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5neHNSb290TW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBTdGF0ZUZhY3RvcnksXHJcbiAgICAgICAgU3RhdGVDb250ZXh0RmFjdG9yeSxcclxuICAgICAgICBBY3Rpb25zLFxyXG4gICAgICAgIEludGVybmFsQWN0aW9ucyxcclxuICAgICAgICBJbnRlcm5hbERpc3BhdGNoZXIsXHJcbiAgICAgICAgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgICAgICBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyxcclxuICAgICAgICBTdG9yZSxcclxuICAgICAgICBTdGF0ZVN0cmVhbSxcclxuICAgICAgICBTZWxlY3RGYWN0b3J5LFxyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIsXHJcbiAgICAgICAgLi4uc3RhdGVzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IFJPT1RfU1RBVEVfVE9LRU4sXHJcbiAgICAgICAgICB1c2VWYWx1ZTogc3RhdGVzXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwcm92aWRlOiBST09UX09QVElPTlMsXHJcbiAgICAgICAgICB1c2VWYWx1ZTogb3B0aW9uc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogTmd4c0NvbmZpZyxcclxuICAgICAgICAgIHVzZUZhY3Rvcnk6IG5neHNDb25maWdGYWN0b3J5LFxyXG4gICAgICAgICAgZGVwczogW1JPT1RfT1BUSU9OU11cclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGZWF0dXJlIG1vZHVsZSBmYWN0b3J5XHJcbiAgICovXHJcbiAgc3RhdGljIGZvckZlYXR1cmUoc3RhdGVzOiBhbnlbXSk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5neHNGZWF0dXJlTW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBTdGF0ZUZhY3RvcnksXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlcixcclxuICAgICAgICAuLi5zdGF0ZXMsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogRkVBVFVSRV9TVEFURV9UT0tFTixcclxuICAgICAgICAgIG11bHRpOiB0cnVlLFxyXG4gICAgICAgICAgdXNlVmFsdWU6IHN0YXRlc1xyXG4gICAgICAgIH1cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgZW5zdXJlU3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IEFjdGlvbk9wdGlvbnMgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0ZXMgYSBtZXRob2Qgd2l0aCBhIGFjdGlvbiBpbmZvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBBY3Rpb24oYWN0aW9uczogYW55IHwgYW55W10sIG9wdGlvbnM/OiBBY3Rpb25PcHRpb25zKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55LCBuYW1lOiBzdHJpbmcsIGRlc2NyaXB0b3I6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPGFueT4pIHtcclxuICAgIGNvbnN0IG1ldGEgPSBlbnN1cmVTdG9yZU1ldGFkYXRhKHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFjdGlvbnMpKSB7XHJcbiAgICAgIGFjdGlvbnMgPSBbYWN0aW9uc107XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xyXG4gICAgICBjb25zdCB0eXBlID0gYWN0aW9uLnR5cGU7XHJcblxyXG4gICAgICBpZiAoIWFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3Rpb24gJHthY3Rpb24ubmFtZX0gaXMgbWlzc2luZyBhIHN0YXRpYyBcInR5cGVcIiBwcm9wZXJ0eWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW1ldGEuYWN0aW9uc1t0eXBlXSkge1xyXG4gICAgICAgIG1ldGEuYWN0aW9uc1t0eXBlXSA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtZXRhLmFjdGlvbnNbdHlwZV0ucHVzaCh7XHJcbiAgICAgICAgZm46IG5hbWUsXHJcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fSxcclxuICAgICAgICB0eXBlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgZW5zdXJlU3RvcmVNZXRhZGF0YSB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IFN0b3JlT3B0aW9ucywgTUVUQV9LRVkgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuXHJcbmNvbnN0IHN0YXRlTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXlthLXpBLVowLTlfXSskJyk7XHJcblxyXG4vKipcclxuICogRXJyb3IgbWVzc2FnZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhdGVOYW1lRXJyb3JNZXNzYWdlID0gbmFtZSA9PlxyXG4gIGAke25hbWV9IGlzIG5vdCBhIHZhbGlkIHN0YXRlIG5hbWUuIEl0IG5lZWRzIHRvIGJlIGEgdmFsaWQgb2JqZWN0IHByb3BlcnR5IG5hbWUuYDtcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0ZXMgYSBjbGFzcyB3aXRoIG5neHMgc3RhdGUgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU3RhdGU8VD4ob3B0aW9uczogU3RvcmVPcHRpb25zPFQ+KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDogYW55KSB7XHJcbiAgICBjb25zdCBtZXRhID0gZW5zdXJlU3RvcmVNZXRhZGF0YSh0YXJnZXQpO1xyXG5cclxuICAgIC8vIEhhbmRsZSBpbmhlcml0YW5jZVxyXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpLmhhc093blByb3BlcnR5KE1FVEFfS0VZKSkge1xyXG4gICAgICBjb25zdCBwYXJlbnRNZXRhID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClbTUVUQV9LRVldO1xyXG5cclxuICAgICAgbWV0YS5hY3Rpb25zID0ge1xyXG4gICAgICAgIC4uLm1ldGEuYWN0aW9ucyxcclxuICAgICAgICAuLi5wYXJlbnRNZXRhLmFjdGlvbnNcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBtZXRhLmNoaWxkcmVuID0gb3B0aW9ucy5jaGlsZHJlbjtcclxuICAgIG1ldGEuZGVmYXVsdHMgPSBvcHRpb25zLmRlZmF1bHRzO1xyXG4gICAgbWV0YS5uYW1lID0gb3B0aW9ucy5uYW1lO1xyXG5cclxuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGVzIG11c3QgcmVnaXN0ZXIgYSAnbmFtZScgcHJvcGVydHlgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXN0YXRlTmFtZVJlZ2V4LnRlc3Qob3B0aW9ucy5uYW1lKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RhdGVOYW1lRXJyb3JNZXNzYWdlKG9wdGlvbnMubmFtZSkpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICcuLi91dGlscy9zZWxlY3Rvci11dGlscyc7XHJcblxyXG4vKipcclxuICogRGVjb3JhdG9yIGZvciBtZW1vaXppbmcgYSBzdGF0ZSBzZWxlY3Rvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3RvcihzZWxlY3RvcnM/OiBhbnlbXSkge1xyXG4gIHJldHVybiAodGFyZ2V0OiBhbnksIGtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpID0+IHtcclxuICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsRm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xyXG5cclxuICAgICAgY29uc3QgbWVtb2l6ZWRGbiA9IGNyZWF0ZVNlbGVjdG9yKFxyXG4gICAgICAgIHNlbGVjdG9ycyxcclxuICAgICAgICBvcmlnaW5hbEZuLFxyXG4gICAgICAgIHsgY29udGFpbmVyQ2xhc3M6IHRhcmdldCwgc2VsZWN0b3JOYW1lOiBrZXkgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgcmV0dXJuIG1lbW9pemVkRm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWxlY3RvcnMgb25seSB3b3JrIG9uIG1ldGhvZHMnKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ0c2xpYl8xLl9fZXh0ZW5kcyIsInRzbGliXzEuX192YWx1ZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBR0EsSUFBYSxnQkFBZ0IsR0FBRyxJQUFJLGNB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